{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"RENDERER",
				"RENDERER_FAKE_GROUND\t(renderer.h)"
			],
			[
				"debugPla",
				"debugPlanePoint\tabc"
			],
			[
				"third",
				"thirdScaled\tabc"
			],
			[
				"sep",
				"separatingPlane\tabc"
			],
			[
				"Game_get",
				"Game_getObjCenter\tabc"
			],
			[
				"sortDi",
				"sortDistA\tabc"
			],
			[
				"world",
				"worldAABB\tabc"
			],
			[
				"Vec3d_di",
				"Vec3d_directionTo\t(glgoose.cpp)"
			],
			[
				"Game",
				"GameObject\tabc"
			],
			[
				"view",
				"viewPos\tabc"
			],
			[
				"aTo",
				"aToPlaneDist\tabc"
			],
			[
				"half",
				"halfwayPoint\tabc"
			],
			[
				"visi",
				"visibleObjectsCount\tabc"
			],
			[
				"for",
				"for\tFor Loop"
			],
			[
				"inter",
				"intersectingObjects\tabc"
			],
			[
				"glPus",
				"glPushMatrix\tabc"
			],
			[
				"UNI",
				"UNIVERSITY_MAP_GRAPH_SIZE\t(university_map_graph.h)"
			],
			[
				"path",
				"pathfinding\tabc"
			],
			[
				"uni",
				"university_map_pathfinding_result\tabc"
			],
			[
				"university",
				"university_map_graph"
			],
			[
				"pa",
				"pathfinding\t(glgoose.cpp)"
			],
			[
				"const",
				"constant\t(character.c)"
			],
			[
				"GL_TE",
				"GL_TEXTURE_2D\tabc"
			],
			[
				"exam",
				"exampleGraph\tabc"
			],
			[
				"debug",
				"debugPathfindingFrom\tabc"
			],
			[
				"debu",
				"debugPathfindingFrom\tabc"
			],
			[
				"den",
				"debugPathfindingTo\tabc"
			],
			[
				"Path",
				"PathfindingState\tabc"
			],
			[
				"resul",
				"resultSize\tabc"
			],
			[
				"Node",
				"NodeState\t(pathfinding.h)"
			],
			[
				"node",
				"nodeStates\tabc"
			],
			[
				"glPush",
				"glPushAttrib\tabc"
			],
			[
				"pos",
				"position\tabc"
			],
			[
				"conn",
				"connectionNode\tabc"
			],
			[
				"res",
				"resultSize\tabc"
			],
			[
				"endNOde",
				"endNodeCost\tabc"
			],
			[
				"Pat",
				"Path_heuristic\tabc"
			],
			[
				"connec",
				"connectionCost\tabc"
			],
			[
				"Un",
				"UnvisitedNodeStateCategory\tabc"
			],
			[
				"Path_",
				"Path_distance\tabc"
			],
			[
				"Path_get",
				"Path_getNodeState\tabc"
			],
			[
				"A",
				"AdjacencyList\tabc"
			],
			[
				"ndoe",
				"nodeID\tabc"
			],
			[
				"ad",
				"adjacencies\tabc"
			],
			[
				"ex",
				"exampleGraph\tabc"
			],
			[
				"min",
				"minCostNode\tabc"
			],
			[
				"es",
				"estimatedTotalCost\tabc"
			],
			[
				"cos",
				"costSoFar\tabc"
			],
			[
				"PAth",
				"Path_heuristic\tabc"
			],
			[
				"AS",
				"AStarNode\tabc"
			],
			[
				"As",
				"AStarNodeState"
			],
			[
				"Pa",
				"PathfindingState\tabc"
			],
			[
				"vec",
				"vec3d.h\t(character.c)"
			],
			[
				"is",
				"isTurning\tabc"
			],
			[
				"target",
				"targetLocation\tabc"
			],
			[
				"Sek",
				"SeekingSoundSourceState\tabc"
			],
			[
				"SEe",
				"SeekingLastSeenState\tabc"
			],
			[
				"See",
				"SeekingLastSeenState\tabc"
			],
			[
				"SE",
				"SeekingSoundSourceState\tabc"
			],
			[
				"Seek",
				"SeekingLastSeenState\tabc"
			],
			[
				"tar",
				"target\tabc"
			],
			[
				"Item",
				"ItemCharacterTarget\t(characterstate.h)"
			],
			[
				"None",
				"NoneCharacterTarget\tabc"
			],
			[
				"targ",
				"targetType\tabc"
			],
			[
				"Cahratar",
				"CharacterTarget\t(characterstate.h)"
			],
			[
				"loca",
				"locationToInvestigate\tabc"
			],
			[
				"has",
				"hasLocationToInvestigate\t(gametypes.h)"
			],
			[
				"DEBUG_SP",
				"DEBUG_COLLISION_SPATIAL_HASH\tabc"
			],
			[
				"charac",
				"characterstate.cpp\t(Makefile)"
			],
			[
				"log",
				"logmsg\tabc"
			],
			[
				"us",
				"usbLoggerData\tabc"
			],
			[
				"leng",
				"lengthToWrite\tabc"
			],
			[
				"user",
				"userData\tabc"
			],
			[
				"usb",
				"usbState\tabc"
			],
			[
				"non",
				"nonIntegralVelocity\tabc"
			],
			[
				"Vec",
				"Vec3d_set\t(game.c)"
			],
			[
				"PhysBody_aply",
				"PhysBody_applyWorldCollision\tabc"
			],
			[
				"matrix",
				"matrix_world\t(export_character_model.py)"
			],
			[
				"GL_LIN",
				"GL_LINE_LOOP\tabc"
			],
			[
				"sphere",
				"sphereAABB\tabc"
			],
			[
				"AABB_from",
				"AABB_fromSphere\tabc"
			],
			[
				"sp",
				"sphereRadius\tabc"
			],
			[
				"spher",
				"sphereRadius\tabc"
			],
			[
				"sph",
				"sphereCenter\tabc"
			],
			[
				"FL",
				"FLT_EPSILON\tabc"
			],
			[
				"format",
				"formatVec3d\tabc"
			],
			[
				"glPop",
				"glPopMatrix\tabc"
			],
			[
				"std",
				"std::cout\tabc"
			],
			[
				"form",
				"formatVec3d\tabc"
			],
			[
				"tri",
				"triangle\tabc"
			],
			[
				"tria",
				"triangleAABB\tabc"
			],
			[
				"maxce",
				"maxCellY\tabc"
			],
			[
				"mincel",
				"minCellX\tabc"
			],
			[
				"buck",
				"buckets\tabc"
			],
			[
				"inserT",
				"insertTriangle\tabc"
			],
			[
				"cell",
				"cellPosY\tabc"
			],
			[
				"spa",
				"spatialHashResults\tabc"
			],
			[
				"spatia",
				"spatialHash\tabc"
			],
			[
				"worl",
				"worldMeshSpatialHash\t(physics.h)"
			],
			[
				"Sp",
				"SpatialHash\tabc"
			],
			[
				"university_map_c",
				"university_map_collision_collision_mesh\tabc"
			],
			[
				"Game_ge",
				"Game_getObjRadius\tabc"
			],
			[
				"re",
				"resultsFound\tabc"
			],
			[
				"max",
				"maxResults\tabc"
			],
			[
				"resu",
				"resultIndex\tabc"
			],
			[
				"V3",
				"Vec3d\tabc"
			],
			[
				"zoom",
				"zoomOut\tabc"
			],
			[
				"spat",
				"spatial_hash\tabc"
			],
			[
				"selec",
				"selectedObject\tabc"
			],
			[
				"wind",
				"window_height\tabc"
			],
			[
				"draw",
				"draw_triangle\tabc"
			],
			[
				"spatialH",
				"spatial_hash_data\tabc"
			],
			[
				"spatial",
				"spatial_hash\t(export_collision_mesh.py)"
			],
			[
				"Spa",
				"spatialHash\t(collision.c)"
			],
			[
				"UNIV",
				"UNIVERSITY_MAP_COLLISION_CELL_OFFSET_IN_DIMENSION\t(university_map_collision.h)"
			],
			[
				"university_map_col",
				"university_map_collision_collision_mesh_hash\t(university_map_collision.h)"
			],
			[
				"buc",
				"bucketIndex\tabc"
			],
			[
				"cel",
				"cellsInDimension\tabc"
			],
			[
				"grid",
				"gridCellSz\tabc"
			],
			[
				"game_tr",
				"game_tri_index\tabc"
			],
			[
				"ver",
				"vert_b\tabc"
			],
			[
				"vert_",
				"vert_a\tabc"
			],
			[
				"exp",
				"exported\t(animation.c)"
			],
			[
				"cli",
				"clickPos\tabc"
			],
			[
				"poin",
				"pointInRect\tabc"
			],
			[
				"gridTo",
				"gridToScreenVec\tabc"
			],
			[
				"off",
				"offsetY\tabc"
			],
			[
				"quan",
				"quantizeVec\tabc"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#ifdef __APPLE__\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\n#include <OpenGL/gl.h>\n#include <OpenGL/glu.h>\n#include <glm/glm.hpp>\n\n// Dear Imgui\n#include \"imgui/imgui.h\"\n// imgui.h needs to be before these\n#include \"imgui/examples/imgui_impl_glut.h\"\n#include \"imgui/examples/imgui_impl_opengl2.h\"\n\n#include \"animation.h\"\n#include \"character.h\"\n#include \"collision.h\"\n#include \"constants.h\"\n#include \"frustum.h\"\n#include \"game.h\"\n#include \"gameobject.h\"\n#include \"gameutils.h\"\n#include \"gl/objloader.hpp\"\n#include \"gl/texture.hpp\"\n#include \"input.h\"\n#include \"nodegraph/nodegraph.hpp\"\n#include \"pathfinding.h\"\n#include \"player.h\"\n#include \"renderer.h\"\n#include \"vec3d.h\"\n\n#include \"garden_map.h\"\n#include \"garden_map_collision.h\"\n#include \"garden_map_graph.h\"\n\n#include \"character_anim.h\"\n#include \"goose_anim.h\"\n\n#define FREEVIEW_SPEED 0.2f\n\n#define DEBUG_LOG_RENDER 0\n#define DEBUG_TEXT_BASIC 0\n#define DEBUG_OBJECTS 0\n#define DEBUG_RAYCASTING 0\n#define DEBUG_MODELS 0\n\n#define DEBUG_ANIMATION 0\n#define DEBUG_ANIMATION_MORE 0\n#define DEBUG_ATTACHMENT 0\n\n#define DEBUG_PHYSICS 0\n\n#define DEBUG_COLLISION_MESH 0\n#define DEBUG_COLLISION_MESH_MORE 0\n#define DEBUG_COLLISION_SPATIAL_HASH 0\n#define DEBUG_COLLISION_SPATIAL_HASH_RAYCAST 0\n#define DEBUG_COLLISION_SPATIAL_HASH_TRIS 0\n#define DEBUG_COLLISION_MESH_AABB 0\n\n#define DEBUG_AABB 0\n#define DEBUG_FRUSTUM 0\n#define DEBUG_ZBUFFER_INTERSECTING 0\n#define DEBUG_PAINTERS_ALGORITHM_SEPARATING_PLANE 0\n\n#define DEBUG_PATHFINDING_GRAPH 0\n#define DEBUG_PATHFINDING 0\n#define DEBUG_PATHFINDING_AUTO 0\n\n#define DEBUG_PROFILING 0\n\n#define USE_SPRITES 0\n#define USE_LIGHTING 1\n#define USE_LIGHTING_STATIC_ONLY 1\n#define USE_FLAT_SHADING 1\n#define USE_ANIM_FRAME_LERP 1\n#define ENABLE_NODEGRAPH_EDITOR 0\n\nint glgooseFrame = 0;\nint updateSkipRate = 1;\n\n// actual vector representing the freeview camera's direction\nfloat cameraLX = 0.0f, cameraLZ = -1.0f;\n// XZ position of the freeview camera\nVec3d freeViewPos = {0.0f, 50.0f, 0.0f};\n// freeview camera angle\nfloat cameraAngle = 180.0f;\nbool enableControlsInFreeView = false;\nint frustumPlaneToTest = -1;\n\nstatic Frustum frustum;\nstatic float fovy = DEFAULT_FOVY;\nstatic float aspect = 800 / 600;\nstatic Vec3d upVector = {0.0f, 1.0f, 0.0f};\nstatic float nearPlane = DEFAULT_NEARPLANE;\nstatic float farPlane = DEFAULT_FARPLANE;\n\nbool keysDown[127];\nInput input;\nGameObject* selectedObject = NULL;\n\nPhysWorldData physWorldData = {garden_map_collision_collision_mesh,\n                               GARDEN_MAP_COLLISION_LENGTH,\n                               &garden_map_collision_collision_mesh_hash,\n                               /*gravity*/ -9.8 * N64_SCALE_FACTOR,\n                               /*viscosity*/ 0.05,\n                               /*waterHeight*/ WATER_HEIGHT};\n\n// crap for gluProject/gluUnProject\nGLdouble lastModelView[16];\nGLdouble lastProjection[16];\nGLint lastViewport[4];\n\n// profiling\nfloat profAvgCharacters = 0;\nfloat profAvgPhysics = 0;\nfloat profAvgDraw = 0;\nfloat profAvgPath = 0;\n\nObjModel models[MAX_MODEL_TYPE];\n\nstd::vector<GLuint> sprites[MAX_SPRITE_TYPE];\n\nchar* GooseMeshTypeStrings[] = {\n    \"goosebody_goosebodymesh\",      //\n    \"goosehead_gooseheadmesh\",      //\n    \"gooseleg_l_gooseleg_lmesh\",    //\n    \"goosefoot_l_goosefoot_lmesh\",  //\n    \"gooseleg_r_gooseleg_rmesh\",    //\n    \"goosefoot_r_goosefoot_rmesh\",  //\n    \"gooseneck_gooseneckmesh\",      //\n    \"MAX_GOOSE_MESH_TYPE\",          //\n};\n\nchar* CharacterMeshTypeStrings[] = {\n    \"gkbicep.l_gkbicep_lrmesh\",      // characterbicep_l_characterbicep_lmesh\n    \"gkbicep.r_gkbicep_rmesh\",       // characterbicep_r_characterbicep_rmesh\n    \"gkfoot.l_gkfoot_lrmesh\",        // characterfoot_l_characterfoot_lmesh\n    \"gkfoot.r_gkfoot_rmesh\",         // characterfoot_r_characterfoot_rmesh\n    \"gkforearm.l_gkforearm_lrmesh\",  // characterforearm_l_characterforearm_lmesh\n    \"gkforearm.r_gkforearm_rmesh\",  // characterforearm_r_characterforearm_rmesh\n    \"gkhead_gkheadmesh\",            // characterhead_characterheadmesh\n    \"gkshin.l_gkshin_lmesh\",        // charactershin_l_charactershin_lmesh\n    \"gkshin.r_gkshin_rmesh\",        // charactershin_r_charactershin_rmesh\n    \"gktorso_gktorsomesh\",          // charactertorso_charactertorsomesh\n    \"gkthigh.l_gkthigh_lmesh\",      // characterthigh_l_characterthigh_lmesh\n    \"gkthigh.r_gkthigh_rmesh\",      // characterthigh_r_characterthigh_rmesh\n};\n\nstd::vector<glm::vec3> spriteVertices = {\n    {0.0f, 1.0f, 0.0f},  //\n    {1.0f, 0.0f, 0.0f},  //\n    {0.0f, 0.0f, 0.0f},  //\n    {0.0f, 1.0f, 0.0f},  //\n    {1.0f, 1.0f, 0.0f},  //\n    {1.0f, 0.0f, 0.0f},  //\n};\nstd::vector<glm::vec2> spriteUVs = {\n    {0.0f, 1.0f},  //\n    {1.0f, 0.0f},  //\n    {0.0f, 0.0f},  //\n    {0.0f, 1.0f},  //\n    {1.0f, 1.0f},  //\n    {1.0f, 0.0f},  //\n};\n\nint debugPathfindingFrom = 3;\nint debugPathfindingTo = 8;\nGraph* pathfindingGraph = &garden_map_graph;\nPathfindingState* pathfindingState = &garden_map_graph_pathfinding_state;\n\nstatic NodeGraph nodeGraph = NodeGraph();\nstatic int selectedNode = -1;\n\nAABB* localAABBs = garden_map_bounds;\nstatic int frustumCulled = 0;\n\nvoid loadModel(ModelType modelType, char* modelfile, char* texfile) {\n  // the map exporter scales the world up by this much, so we scale up the\n  // meshes to match\n  loadOBJ(modelfile, models[modelType], N64_SCALE_FACTOR);\n  models[modelType].texture = loadBMP_custom(texfile);\n}\n\nvoid loadSprite(SpriteType spriteType, std::vector<std::string> texfiles) {\n  std::for_each(\n      texfiles.begin(), texfiles.end(), [spriteType](std::string& texfile) {\n        sprites[spriteType].push_back(loadBMP_custom(texfile.c_str()));\n      });\n}\n\nvoid screenCoordsToWorld(Vec3d* screenPos, Vec3d* result) {\n  GLdouble res[3];\n\n  gluUnProject(/*winX*/ screenPos->x,\n               /*winY*/ screenPos->y,\n               /*winZ*/ screenPos->z, lastModelView, lastProjection,\n               lastViewport,\n               /*objX*/ &res[0],\n               /*objY*/ &res[1],\n               /*objZ*/ &res[2]);\n\n  Vec3d_init(result, res[0], res[1], res[2]);\n}\n\nbool worldCoordsToScreen(Vec3d* pos,\n                         Vec3d* result,\n                         GLdouble* modelview,\n                         GLdouble* projection) {\n  GLdouble scr[3];\n\n  bool success = gluProject(pos->x, pos->y, pos->z, modelview, projection,\n                            lastViewport, &scr[0], &scr[1], &scr[2]);\n\n  int screenSizeX = lastViewport[2];\n  int screenSizeY = lastViewport[3];\n\n  if (success &&\n      // valid number range\n      (scr[0] >= 0 && scr[1] >= 0 && scr[2] >= 0) &&\n      (scr[0] <= FLT_MAX && scr[1] <= FLT_MAX && scr[2] <= FLT_MAX) &&\n      // inside 2d viewport extents\n      (scr[0] < screenSizeX && scr[1] < screenSizeY)) {\n    result->x = scr[0];\n    result->y = scr[1];\n    result->z = scr[2];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstd::string formatVec3d(Vec3d* self) {\n  char buffer[60];\n  sprintf(buffer, \"{x:%.3f, y:%.3f, z:%.3f}\", self->x, self->y, self->z);\n  return buffer;\n}\n\nstd::string formatEuler(EulerDegrees* self) {\n  char buffer[60];\n  sprintf(buffer, \"{x:%.3f, y:%.3f, z:%.3f}\", self->x, self->y, self->z);\n  return buffer;\n}\n\nvoid drawGUI() {\n  Game* game = Game_get();\n  GameObject* obj = selectedObject;\n  Character* selectedCharacter =\n      obj == Game_get()->characters->obj ? Game_get()->characters : NULL;\n  ImGuiInputTextFlags inputFlags =\n      ImGuiInputTextFlags_EnterReturnsTrue;  // only update on blur\n\n  ImGui::Begin(\"Objects\");  // Create a window\n  for (int i = 0; i < game->worldObjectsCount; i++) {\n    GameObject* listObj = game->worldObjects + i;\n    if (ImGui::Selectable(\n            (std::to_string(i) + \" \" + ModelTypeStrings[listObj->modelType])\n                .c_str(),\n            listObj == obj)) {\n      selectedObject = listObj;\n    }\n  }\n  ImGui::End();\n\n  ImGui::Begin(\"Object Inspector\");  // Create a window\n\n  // Display some text (you can use a format strings too)\n  ImGui::Text(\"Selected object: %d (%s)\", obj ? obj->id : -1,\n              obj ? ModelTypeStrings[obj->modelType] : \"none\");\n\n  if (obj) {\n    int spatialHashResults[100];\n    Vec3d objCenter;\n    Game_getObjCenter(obj, &objCenter);\n\n    if (ImGui::CollapsingHeader(\"Object\", ImGuiTreeNodeFlags_DefaultOpen)) {\n      ImGui::InputFloat3(\"Position\", (float*)&obj->position, \"%.3f\",\n                         inputFlags);\n      ImGui::InputFloat3(\"Rotation\", (float*)&obj->rotation, \"%.3f\",\n                         inputFlags);\n      ImGui::InputFloat3(\n          \"centroidOffset\",\n          (float*)&modelTypesProperties[obj->modelType].centroidOffset, \"%.3f\",\n          inputFlags);\n\n      ImGui::InputFloat(\"radius\",\n                        (float*)&modelTypesProperties[obj->modelType].radius,\n                        0.1, 1.0, \"%.3f\", inputFlags);\n      ImGui::InputInt(\"subtype\", (int*)&obj->subtype, 0, 1,\n                      ImGuiInputTextFlags_ReadOnly);\n\n      AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n\n      ImGui::InputFloat3(\"worldAABB.min\", (float*)&worldAABB.min, \"%.3f\",\n                         ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat3(\"worldAABB.max\", (float*)&worldAABB.max, \"%.3f\",\n                         ImGuiInputTextFlags_ReadOnly);\n    }\n    if (obj->physBody) {\n      if (ImGui::CollapsingHeader(\"Physics\", ImGuiTreeNodeFlags_DefaultOpen)) {\n        ImGui::InputInt(\"physBody\", (int*)&obj->physBody->id, 0, 1,\n                        ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"phys Velocity\",\n                           (float*)&obj->physBody->nonIntegralVelocity, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"phys Acceleration\",\n                           (float*)&obj->physBody->nonIntegralAcceleration,\n                           \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n\n        ImGui::InputFloat3(\"phys position\", (float*)&obj->physBody->position,\n                           \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"phys prevPosition\",\n                           (float*)&obj->physBody->prevPosition, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputInt(\"phys enabled\", (int*)&obj->physBody->enabled, 0, 1,\n                        ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputInt(\"phys controlled\", (int*)&obj->physBody->controlled, 0,\n                        1, ImGuiInputTextFlags_ReadOnly);\n      }\n    }\n    if (obj->animState) {\n      if (ImGui::CollapsingHeader(\"Animation\",\n                                  ImGuiTreeNodeFlags_DefaultOpen)) {\n        ImGui::InputInt(\"state\", (int*)&obj->animState->state, 0, 1,\n                        ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"progress\", (float*)&obj->animState->progress, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n      }\n    }\n    if (selectedCharacter) {\n      if (ImGui::CollapsingHeader(\"Character\",\n                                  ImGuiTreeNodeFlags_DefaultOpen)) {\n        Vec3d heading;\n        GameUtils_directionFromTopDownAngle(obj->rotation.y, &heading);\n        ImGui::InputFloat3(\"heading\", (float*)&heading, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"targetLocation\",\n                           (float*)&selectedCharacter->targetLocation, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::Text(\"state: %s\",\n                    CharacterStateStrings[selectedCharacter->state]);\n\n        ImGui::InputFloat(\"speedMultiplier\",\n                          (float*)&selectedCharacter->speedMultiplier, 0.1, 1.0,\n                          \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"heading speed scale\",\n                          (float*)&selectedCharacter->speedScaleForHeading, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\n            \"heading turn scale\",\n            (float*)&selectedCharacter->turningSpeedScaleForHeading, 0.1, 1.0,\n            \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"arrival speed scale\",\n                          (float*)&selectedCharacter->speedScaleForArrival, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputInt(\"pathProgress\", (int*)&selectedCharacter->pathProgress,\n                        0, 1, ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"pathSegmentProgress\",\n                          (float*)&selectedCharacter->pathSegmentProgress, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        if (selectedCharacter->pathfindingResult) {\n          ImGui::Text(\"path:\");\n          int i;\n          int* pathNodeID;\n\n          for (i = 0,\n              pathNodeID = selectedCharacter->pathfindingResult->result;  //\n               i < selectedCharacter->pathfindingResult->resultSize;      //\n               i++, pathNodeID++) {\n            ImGui::Text(\"%d: %d\", i, *pathNodeID);\n          }\n        }\n      }\n    }\n\n    if (ImGui::CollapsingHeader(\"Collision\")) {\n      ImGui::InputInt(\"testCollisionResult\", (int*)&testCollisionResult, 0, 1,\n                      inputFlags);\n\n      std::string collKeys;\n      if (testCollisionResults.size()) {\n        std::map<int, SphereTriangleCollision>::iterator collIter =\n            testCollisionResults.begin();\n\n        while (collIter != testCollisionResults.end()) {\n          collKeys += std::to_string(collIter->first) + \",\";\n\n          collIter++;\n        }\n      }\n      ImGui::Text(\"colliding tris=%s\", collKeys.c_str());\n\n      int spatialHashResultsCount = SpatialHash_getTriangles(\n          &objCenter, Game_getObjRadius(obj),\n          physWorldData.worldMeshSpatialHash, spatialHashResults,\n          /*maxResults*/ 100);\n\n      std::string bucketKeys;\n      int i;\n      for (i = 0; i < spatialHashResultsCount; i++) {\n        bucketKeys += std::to_string(spatialHashResults[i]) + \",\";\n      }\n\n      ImGui::Text(\"grid pos x=%f, y=%f\",\n                  SpatialHash_unitsToGridFloatForDimension(\n                      objCenter.x, physWorldData.worldMeshSpatialHash),\n                  SpatialHash_unitsToGridFloatForDimension(\n                      objCenter.z, physWorldData.worldMeshSpatialHash));\n\n      ImGui::Text(\"current bucket tris=%s\", bucketKeys.c_str());\n    }\n  }\n\n  if (ImGui::CollapsingHeader(\"Global\", ImGuiTreeNodeFlags_DefaultOpen)) {\n    ImGui::InputFloat(\"physWorldData.gravity\", (float*)&physWorldData.gravity,\n                      1.0, 10.0, \"%.3f\", inputFlags);\n\n    ImGui::InputInt(\"updateSkipRate\", (int*)&updateSkipRate, 1, 10, inputFlags);\n    updateSkipRate = MAX(updateSkipRate, 1);\n  }\n\n  if (ImGui::CollapsingHeader(\"Camera\",\n#if DEBUG_FRUSTUM\n                              ImGuiTreeNodeFlags_DefaultOpen\n#else\n                              0\n#endif\n                              )) {\n    ImGui::InputFloat3(\"viewPos\", (float*)&game->viewPos, \"%.3f\");\n    ImGui::InputFloat3(\"viewTarget\", (float*)&game->viewTarget, \"%.3f\");\n    ImGui::InputFloat3(\"freeViewPos\", (float*)&freeViewPos, \"%.3f\");\n    ImGui::Checkbox(\"enableControlsInFreeView\", &enableControlsInFreeView);\n    ImGui::Combo(\"plane to test\", &frustumPlaneToTest, FrustumPlanesStrings,\n                 NUM_FRUSTUM_PLANES);\n\n    if (obj) {\n      {\n        ImGui::Text(\"frustum test results for obj=%d\", obj->id);\n\n        AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n\n        ImGui::Text(\"boxInFrustum: %s\",\n                    FrustumTestResultStrings[Frustum_boxInFrustum(&frustum,\n                                                                  &worldAABB)]);\n        ImGui::Text(\"boxInFrustumNaive: %s\",\n                    FrustumTestResultStrings[Frustum_boxInFrustumNaive(\n                        &frustum, &worldAABB)]);\n        ImGui::Text(\"Per plane tests:\");\n        for (int i = 0; i < NUM_FRUSTUM_PLANES; ++i) {\n          ImGui::Text(\"%s: %s\", FrustumPlanesStrings[i],\n                      FrustumTestResultStrings[Frustum_boxFrustumPlaneTestPN(\n                          &frustum, &worldAABB, i)]);\n        }\n      }\n\n#if DEBUG_PAINTERS_ALGORITHM_SEPARATING_PLANE\n      if (obj) {\n        GameObject* a = game->player.goose;\n        GameObject* b = selectedObject;\n        RendererSortDistance sortDistA, sortDistB;\n        Plane separatingPlane;\n        Vec3d aCenter, bCenter, aClosestPoint, bClosestPoint,\n            aReallyClosestPoint, bReallyClosestPoint;\n        Game_getObjCenter(a, &aCenter);\n        Game_getObjCenter(b, &bCenter);\n        AABB aabbA = Renderer_getWorldAABB(localAABBs, a);\n        AABB aabbB = Renderer_getWorldAABB(localAABBs, b);\n        sortDistA = (RendererSortDistance){\n            /*obj*/ game->player.goose,\n            /*distance*/ 0,\n            /*worldAABB*/\n            Renderer_getWorldAABB(localAABBs, game->player.goose)};\n        sortDistB = (RendererSortDistance){\n            /*obj*/ selectedObject,\n            /*distance*/ 0,\n            /*worldAABB*/ Renderer_getWorldAABB(localAABBs, selectedObject)};\n        int aCloser = Renderer_isCloserBySeparatingPlane(&sortDistA, &sortDistB,\n                                                         &game->viewPos);\n\n        Renderer_closestPointOnAABB(&aabbA, &bCenter, &aClosestPoint);\n        Renderer_closestPointOnAABB(&aabbB, &aCenter, &bClosestPoint);\n\n        Renderer_closestPointOnAABB(&aabbA, &bClosestPoint,\n                                    &aReallyClosestPoint);\n        Renderer_closestPointOnAABB(&aabbB, &aClosestPoint,\n                                    &bReallyClosestPoint);\n\n        Renderer_getSeparatingPlane(&aReallyClosestPoint, &bReallyClosestPoint,\n                                    &separatingPlane);\n\n        float planeToADist = Plane_distance(&separatingPlane, &aCenter);\n        float planeToViewDist =\n            Plane_distance(&separatingPlane, &game->viewPos);\n\n        ImGui::InputFloat3(\"aCenter\", (float*)&aCenter, \"%.3f\");\n        ImGui::InputFloat3(\"separatingPlane.point\",\n                           (float*)&separatingPlane.point, \"%.3f\");\n        ImGui::InputFloat(\"planeToADist\", (float*)&planeToADist, 0.1, 1.0,\n                          \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"planeToViewDist\", (float*)&planeToViewDist, 0.1, 1.0,\n                          \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::Text(aCloser == -1 ? \"goose is closer than selectedObject\"\n                                  : \"goose is NOT closer than selectedObject\");\n      }\n#endif\n    }\n\n    if (ImGui::CollapsingHeader(\"Camera++\")) {\n      ImGui::InputFloat3(\"ntl\", (float*)&frustum.ntl, \"%.3f\");\n      ImGui::InputFloat3(\"ntr\", (float*)&frustum.ntr, \"%.3f\");\n      ImGui::InputFloat3(\"nbl\", (float*)&frustum.nbl, \"%.3f\");\n      ImGui::InputFloat3(\"nbr\", (float*)&frustum.nbr, \"%.3f\");\n      ImGui::InputFloat3(\"ftl\", (float*)&frustum.ftl, \"%.3f\");\n      ImGui::InputFloat3(\"ftr\", (float*)&frustum.ftr, \"%.3f\");\n      ImGui::InputFloat3(\"fbl\", (float*)&frustum.fbl, \"%.3f\");\n      ImGui::InputFloat3(\"fbr\", (float*)&frustum.fbr, \"%.3f\");\n      ImGui::InputFloat(\"nearD\", (float*)&frustum.nearD, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"farD\", (float*)&frustum.farD, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"aspect\", (float*)&frustum.aspect, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"fovy\", (float*)&frustum.fovy, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"tang\", (float*)&frustum.tang, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"nw\", (float*)&frustum.nw, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"nh\", (float*)&frustum.nh, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"fw\", (float*)&frustum.fw, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"fh\", (float*)&frustum.fh, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n    }\n  }\n\n  if (ImGui::CollapsingHeader(\"Profiling\",\n#if DEBUG_PROFILING\n                              ImGuiTreeNodeFlags_DefaultOpen\n#else\n                              0\n#endif\n                              )) {\n    ImGui::Text(\"Frametime %.3f ms (%.1f FPS)\",\n                1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\n\n    ImGui::Text(\"Phys=%.3fms, Char=%.3f ms, Draw=%.3f ms, Path=%.3f ms\",\n                profAvgPhysics, profAvgCharacters, profAvgDraw, profAvgPath);\n    ImGui::InputInt(\"frustumCulled\", (int*)&frustumCulled, 0, 10,\n                    ImGuiInputTextFlags_ReadOnly);\n  }\n\n  Vec3d* goosePos = &Game_get()->player.goose->position;\n  if (ImGui::CollapsingHeader(\"Pathfinding\")) {\n#if DEBUG_PATHFINDING\n    ImGui::InputInt(\"debugPathfindingFrom\", (int*)&debugPathfindingFrom, 1, 10,\n                    inputFlags);\n    ImGui::InputInt(\"debugPathfindingTo\", (int*)&debugPathfindingTo, 1, 10,\n                    inputFlags);\n\n    if (ImGui::Button(\"print pos\")) {\n      printf(\"{%.3f, %.3f, %.3f}\\n\", goosePos->x, goosePos->y, goosePos->z);\n    }\n\n#endif\n  }\n\n#if ENABLE_NODEGRAPH_EDITOR\n  drawNodeGraphGUI(nodeGraph, goosePos, \"garden_map_graph\", \"garden_map_graph\",\n                   selectedNode);\n#endif\n\n  ImGui::End();\n}\n\nvoid drawString(const char* string, int x, int y) {\n  int w, h;\n  const char* c;\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n\n  glMatrixMode(GL_PROJECTION);\n  glPushMatrix();\n  glLoadIdentity();\n  w = glutGet(GLUT_WINDOW_WIDTH);\n  h = glutGet(GLUT_WINDOW_HEIGHT);\n  glOrtho(0, glutGet(GLUT_WINDOW_WIDTH), 0, glutGet(GLUT_WINDOW_HEIGHT), -1, 1);\n\n  glMatrixMode(GL_MODELVIEW);\n  glPushMatrix();\n  glLoadIdentity();\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glColor3f(1.0f, 1.0f, 1.0f);\n\n  glRasterPos2i(x, y);\n  for (c = string; *c != '\\0'; c++) {\n    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, *c);\n  }\n  glPopMatrix();  // GL_MODELVIEW\n\n  glMatrixMode(GL_PROJECTION);\n  glPopMatrix();  // GL_PROJECTION\n\n  glPopAttrib();  // GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT\n}\n\nvoid drawStringAtPointLocalOrWorld(const char* string,\n                                   Vec3d* pos,\n                                   int centered,\n                                   int local) {\n  Vec3d screen;  // x, y, zdepth\n  bool success;\n  if (local) {\n    GLdouble modelview[16];\n    GLdouble projection[16];\n    glGetDoublev(GL_MODELVIEW_MATRIX, modelview);\n    glGetDoublev(GL_PROJECTION_MATRIX, projection);\n    success = worldCoordsToScreen(pos, &screen, modelview, projection);\n  } else {\n    success = worldCoordsToScreen(pos, &screen, lastModelView, lastProjection);\n  }\n  if (!success) {\n    return;\n  }\n\n  int stringLength;\n\n  stringLength = strlen(string);\n\n  drawString(string, screen.x - (centered ? (stringLength * 8 / 2) : 0.0),\n             screen.y);\n}\n\nvoid drawStringAtPoint(const char* string, Vec3d* pos, int centered) {\n  drawStringAtPointLocalOrWorld(string, pos, centered, FALSE);\n}\n\nvoid drawStringAtPointLocal(const char* string, int centered) {\n  Vec3d pos;\n  Vec3d_origin(&pos);\n\n  drawStringAtPointLocalOrWorld(string, &pos, centered, TRUE);\n}\n\nvoid drawSprite(SpriteType spriteType,\n                int frame,\n                int x,\n                int y,\n                int width,\n                int height) {\n  const char* c;\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_POLYGON_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_CULL_FACE);\n\n  glMatrixMode(GL_PROJECTION);\n  glPushMatrix();\n  glLoadIdentity();\n  glOrtho(0, glutGet(GLUT_WINDOW_WIDTH), 0, glutGet(GLUT_WINDOW_HEIGHT), -1, 1);\n\n  glMatrixMode(GL_MODELVIEW);\n  glPushMatrix();\n  glLoadIdentity();\n  glDisable(GL_LIGHTING);\n\n  glTranslatef(x, y, 0);\n\n  glScalef(width, height, 1);\n\n  glEnable(GL_TEXTURE_2D);\n  glBindTexture(GL_TEXTURE_2D, sprites[spriteType].at(frame));\n  glBegin(GL_TRIANGLES);\n  for (int ivert = 0; ivert < spriteVertices.size(); ++ivert) {\n    glTexCoord2d(spriteUVs[ivert].x, spriteUVs[ivert].y);\n    glVertex3f(spriteVertices[ivert].x, spriteVertices[ivert].y,\n               spriteVertices[ivert].z);\n  }\n  glEnd();\n\n  glPopMatrix();  // GL_MODELVIEW\n\n  glMatrixMode(GL_PROJECTION);\n  glPopMatrix();  // GL_PROJECTION\n\n  glPopAttrib();  // GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n                  // GL_POLYGON_BIT\n}\n\nvoid drawSpriteAtPoint(SpriteType spriteType,\n                       int frame,\n                       int width,\n                       int height,\n                       Vec3d* pos,\n                       int centered) {\n  Vec3d screen;  // x, y, zdepth\n  bool success =\n      worldCoordsToScreen(pos, &screen, lastModelView, lastProjection);\n  if (!success) {\n    return;\n  }\n\n  drawSprite(spriteType, frame, screen.x - (centered ? width / 2.0 : 0.0),\n             screen.y - (centered ? height / 2.0 : 0.0), width, height);\n}\n\nvoid drawMarker(float r, float g, float b, float radius) {\n  glPushAttrib(GL_LIGHTING_BIT | GL_TEXTURE_BIT | GL_CURRENT_BIT |\n               GL_DEPTH_BUFFER_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_DEPTH_TEST);\n  glColor3f(r, g, b);  // red\n  glutWireSphere(/*radius*/ radius, /*slices*/ 10, /*stacks*/ 10);\n  glPopAttrib();\n}\n\nvoid drawMarkerAtPoint(float r, float g, float b, float radius, Vec3d* pos) {\n  glPushMatrix();\n  glTranslatef(pos->x, pos->y, pos->z);\n  drawMarker(r, g, b, radius);\n  glPopMatrix();\n}\n\nvoid drawLine(Vec3d* start, Vec3d* end) {\n  glBegin(GL_LINES);\n  glVertex3f(start->x, start->y, start->z);\n  glVertex3f(end->x, end->y, end->z);\n  glEnd();\n}\n\nvoid drawMotionVectorLine(Vec3d* from, Vec3d* to) {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_DEPTH_BUFFER_BIT);\n  glPushMatrix();\n\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_DEPTH_TEST);\n  glColor3f(0.0f, 0.0f, 0.0f);  // blue\n  drawLine(from, to);\n  glPushMatrix();\n  glTranslatef(from->x, from->y, from->z);\n  drawMarker(0.8f, 0.0f, 0.0f, 1);  // from red\n  glPopMatrix();\n  glPushMatrix();\n  glTranslatef(to->x, to->y, to->z);\n  drawMarker(0.0f, 0.8f, 0.0f, 1);  // to green\n  glPopMatrix();\n  glPopAttrib();\n  glPopMatrix();\n}\n\nvoid drawTriNormal(Vec3d* normal, Vec3d* position) {\n  Vec3d from, to;\n\n  from = *position;\n  to = *normal;\n  Vec3d_mulScalar(&to, 20.0);\n  Vec3d_add(&to, position);\n\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_DEPTH_BUFFER_BIT);\n  glPushMatrix();\n\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_DEPTH_TEST);\n\n  glBegin(GL_LINES);\n  glColor3f(0.0f, 0.0f, 1.0f);\n  glVertex3f(from.x, from.y, from.z);\n  glColor3f(1.0f, 1.0f, 0.0f);\n  glVertex3f(to.x, to.y, to.z);\n  glEnd();\n\n  glPopAttrib();\n  glPopMatrix();\n}\n\nvoid drawRaycastLine(RaycastTraceEvent raycast) {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glPushMatrix();\n\n  // create end point based on origin and direction\n  Vec3d rayEnd = raycast.direction;\n  Vec3d_mulScalar(&rayEnd, 1000.0);\n  Vec3d_add(&rayEnd, &raycast.origin);\n\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  if (raycast.result) {\n    glColor3f(1.0f, 1.0f, 1.0f);\n  } else {\n    glColor3f(1.0f, 0.0f, 0.0f);\n  }\n  drawLine(&raycast.origin, &rayEnd);\n  glPushMatrix();\n  glTranslatef(raycast.origin.x, raycast.origin.y, raycast.origin.z);\n  drawMarker(0.8f, 0.8f, 0.8f, 1);\n  glPopMatrix();\n  glPushMatrix();\n  glTranslatef(rayEnd.x, rayEnd.y, rayEnd.z);\n  drawMarker(0.8f, 0.8f, 0.8f, 1);\n  glPopMatrix();\n  glPopAttrib();\n  glPopMatrix();\n}\n\nvoid drawPhysBall(float radius) {\n  glPushAttrib(GL_LIGHTING_BIT | GL_TEXTURE_BIT | GL_CURRENT_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glColor3f(1.0, 1.0, 0.0);  // yellow\n  glutWireSphere(/*radius*/ radius, /*slices*/ 10, /*stacks*/ 10);\n  glPopAttrib();\n}\n\nvoid Frustum_drawPoints(Frustum* frustum) {\n  glColor3f(1.0, 1.0, 0.0);  // yellow\n  glBegin(GL_POINTS);\n\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  glEnd();\n}\n\nvoid Frustum_drawLines(Frustum* frustum) {\n  glColor3f(1.0, 0.0, 0.0);\n  glBegin(GL_LINE_LOOP);\n  // near plane\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // far plane\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // bottom plane\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // top plane\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // left plane\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // right plane\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  glEnd();\n}\n\nvoid Frustum_drawPlanes(Frustum* frustum) {\n  glEnable(GL_BLEND);\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n  glColor4f(0.0f, 0.0, 1.0, 0.1);\n  glBegin(GL_QUADS);\n\n  // // near plane\n  // glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  // glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  // glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  // glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n\n  // // far plane\n  // glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  // glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  // glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  // glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  // // bottom plane\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n\n  // // top plane\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n\n  // left plane\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n\n  // right plane\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  glDisable(GL_BLEND);\n  glEnd();\n}\n\nvoid drawMesh(ObjMesh& mesh, GLuint texture) {\n  glColor3f(1.0f, 1.0f, 1.0f);  // whitish\n  glEnable(GL_TEXTURE_2D);\n  glBindTexture(GL_TEXTURE_2D, texture);\n  glBegin(GL_TRIANGLES);\n  for (int ivert = 0; ivert < mesh.vertices.size(); ++ivert) {\n    glTexCoord2d(mesh.uvs[ivert].x, mesh.uvs[ivert].y);\n    glNormal3f(mesh.normals[ivert].x, mesh.normals[ivert].y,\n               mesh.normals[ivert].z);\n    glVertex3f(mesh.vertices[ivert].x, mesh.vertices[ivert].y,\n               mesh.vertices[ivert].z);\n  }\n  glEnd();\n  glDisable(GL_TEXTURE_2D);\n}\n\nObjMesh& getMeshForModelType(ModelType modelType, int subtype) {\n  try {\n    return models[modelType].meshList.at(subtype);\n  } catch (const std::out_of_range& oor) {\n    std::cerr << \"Out of Range error: \" << oor.what() << '\\n';\n  }\n  printf(\"did you forget to load \\\"%s\\\"?\\n\", ModelTypeStrings[modelType]);\n  invariant(false);\n}\n\nvoid drawMeshesForModel(ModelType modelType, int subtype) {\n  ObjModel& model = models[modelType];\n  ObjMesh& mesh = getMeshForModelType(modelType, subtype);\n  // draw mesh\n  drawMesh(mesh, model.texture);\n}\n\nchar* getMeshNameForModelMeshPart(ModelType modelType, int meshPart) {\n  switch (modelType) {\n    case GooseModel:\n      return GooseMeshTypeStrings[meshPart];\n    default:\n      return CharacterMeshTypeStrings[meshPart];\n  }\n}\n\nint getAnimationNumModelMeshParts(ModelType modelType) {\n  switch (modelType) {\n    case GooseModel:\n      return MAX_GOOSE_MESH_TYPE;\n    default:\n      return MAX_CHARACTER_MESH_TYPE;\n  }\n}\n\nAnimationRange* getCurrentAnimationRange(GameObject* obj) {\n  if (obj->modelType == GooseModel) {\n    return &goose_anim_ranges[(GooseAnimType)obj->animState->state];\n  } else {\n    return &character_anim_ranges[(CharacterAnimType)obj->animState->state];\n  }\n}\n\nAnimationFrame* getAnimData(ModelType modelType) {\n  switch (modelType) {\n    case GooseModel:\n      return goose_anim_data;\n    default:\n      return character_anim_data;\n  }\n}\n\nvoid drawModel(GameObject* obj) {\n  if (!obj->visible) {\n    return;\n  }\n\n  ObjModel& model = models[obj->modelType];\n\n  if (Renderer_isAnimatedGameObject(obj)) {\n    // case for multi-part objects using rigid body animation\n    // TODO: generalize this for other model types using other skeletons with\n    // retargetable animations\n\n    AnimationRange* curAnimRange;  // range of frames representing anim clip\n    AnimationInterpolation animInterp;  // interpolation value for frame\n    AnimationFrame animFrame;           // animation frame data for one bone\n    int modelMeshParts = getAnimationNumModelMeshParts(obj->modelType);\n\n    invariant(obj->animState != NULL);\n    curAnimRange = getCurrentAnimationRange(obj);\n\n#if DEBUG_ANIMATION\n    glDisable(GL_DEPTH_TEST);\n    drawMarker(1.0f, 0.0f, 0.0f, 5);  // origin marker, red\n    glEnable(GL_DEPTH_TEST);\n#endif\n\n    AnimationInterpolation_calc(&animInterp, obj->animState, curAnimRange);\n    for (int modelMeshIdx = 0; modelMeshIdx < modelMeshParts; ++modelMeshIdx) {\n#if USE_ANIM_FRAME_LERP\n      AnimationFrame_lerp(\n          &animInterp,  // result of AnimationInterpolation_calc()\n          getAnimData(\n              obj->modelType),  // pointer to start of AnimationFrame list\n          modelMeshParts,       // num bones in rig used by animData\n          modelMeshIdx,         // index of bone in rig to produce transform for\n          &animFrame            // the resultant interpolated animation frame\n      );\n#else\n      AnimationFrame_get(\n          &animInterp,  // result of AnimationInterpolation_calc()\n          getAnimData(\n              obj->modelType),  // pointer to start of AnimationFrame list\n          modelMeshParts,       // num bones in rig used by animData\n          modelMeshIdx,         // index of bone in rig to produce transform for\n          &animFrame);\n#endif\n\n      // push relative transformation matrix, render the mesh, then pop the\n      // relative transform off the matrix stack again\n      glPushMatrix();\n\n      // rotate from z-up (blender) to y-up (opengl) coords\n      glRotatef(-90.0f, 1, 0, 0);\n\n      glTranslatef(animFrame.position.x, animFrame.position.y,\n                   animFrame.position.z);\n\n      glRotatef(animFrame.rotation.x, 1, 0, 0);\n      glRotatef(animFrame.rotation.y, 0, 1, 0);\n      glRotatef(animFrame.rotation.z, 0, 0, 1);\n\n      char* meshName =\n          getMeshNameForModelMeshPart(obj->modelType, animFrame.object);\n      try {\n        ObjMesh& mesh = model.meshList.at(model.meshes.at(meshName));\n        drawMesh(mesh, model.texture);\n      } catch (const std::out_of_range& oor) {\n        std::cerr << \"missing mesh: \" << meshName << \" on model \"\n                  << ModelTypeStrings[obj->modelType] << \"\\n\";\n        invariant(false);\n      }\n\n      // attachment drawing stuff\n      AnimationBoneAttachment& attachment = obj->animState->attachment;\n      if (attachment.modelType != NoneModel &&\n          attachment.boneIndex == modelMeshIdx) {\n#if DEBUG_ATTACHMENT\n        printf(\n            \"drawing attachment %s on %s (animFrame.object=%d) at boneIdx=%d \"\n            \"mesh=%s\\n\",\n            ModelTypeStrings[attachment.modelType],\n            ModelTypeStrings[obj->modelType], animFrame.object,\n            attachment.boneIndex,\n            getMeshNameForModelMeshPart(obj->modelType, attachment.boneIndex));\n#endif\n        glPushMatrix();\n        glTranslatef(attachment.offset.x, attachment.offset.y,\n                     attachment.offset.z);\n        glRotatef(attachment.rotation.x, 1, 0, 0);\n        glRotatef(attachment.rotation.y, 0, 1, 0);\n        glRotatef(attachment.rotation.z, 0, 0, 1);\n        drawMeshesForModel(attachment.modelType, 0);\n        glPopMatrix();\n      }\n\n#if DEBUG_ANIMATION\n      glDisable(GL_DEPTH_TEST);\n      drawMarker(0.0f, 0.0f, 1.0f, 1);  // bone marker, blue\n      glEnable(GL_DEPTH_TEST);\n#endif\n\n#if DEBUG_ANIMATION_MORE\n      // overlay cones\n      glPushMatrix();\n      glRotatef(90.0f, 0, 0,\n                1);               // cone points towards z by default, flip up\n                                  // on the z axis to make cone point up at y\n      glRotatef(90.0f, 0, 1, 0);  // undo our weird global rotation\n      glDisable(GL_TEXTURE_2D);\n      glColor3f(1.0f, 0.0f, 0.0f);  // red\n      // glutSolidCone(4.2, 30, 4, 20);  // cone with 4 slices = pyramid-like\n\n      glColor3f(1.0f, 1.0f, 1.0f);\n      glEnable(GL_TEXTURE_2D);\n      glPopMatrix();\n\n      // overlay text\n      glPushMatrix();\n      drawStringAtPointLocal(\n          getMeshNameForModelMeshPart(obj->modelType, animFrame.object), FALSE);\n      glPopMatrix();\n\n#endif\n\n      glPopMatrix();\n    }\n\n  } else {\n    // case for simple gameobjects with no moving sub-parts\n    drawMeshesForModel(obj->modelType, obj->subtype);\n#if DEBUG_MODELS\n    drawMarker(255.0, 0.0, 255.0, 1);  // obj marker, purple\n#endif\n  }\n}\n\nvoid resizeWindow(int w, int h) {\n  ImGui_ImplGLUT_ReshapeFunc(w, h);\n  // Prevent a divide by zero, when window is too short\n  // (you cant make a window of zero width).\n  if (h == 0)\n    h = 1;\n  aspect = w * 1.0 / h;\n\n  // Use the Projection Matrix\n  glMatrixMode(GL_PROJECTION);\n  // Reset Matrix\n  glLoadIdentity();\n  // Set the viewport to be the entire window\n  glViewport(0, 0, w, h);\n  // Set the correct perspective.\n  gluPerspective(fovy, aspect, nearPlane,\n                 Game_get()->freeView ? 10000 : farPlane);\n  Frustum_setCamInternals(&frustum, fovy, aspect, nearPlane, farPlane);\n  // Get Back to the Modelview\n  glMatrixMode(GL_MODELVIEW);\n}\n\nvoid enableLighting() {\n  GLfloat light_ambient[] = {0.1f, 0.1f, 0.1f, 1.0f};   /* default value */\n  GLfloat light_diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f};   /* default value */\n  GLfloat light_specular[] = {1.0f, 1.0f, 1.0f, 1.0f};  /* default value */\n  GLfloat light_position[] = {1.0f, 1.0f, -1.0f, 0.0f}; /* NOT default value */\n  GLfloat lightModel_ambient[] = {0.2f, 0.2f, 0.2f, 1.0f}; /* default value */\n  GLfloat material_specular[] = {1.0f, 1.0f, 1.0f,\n                                 1.0f}; /* NOT default value */\n  GLfloat material_emission[] = {0.0f, 0.0f, 0.0f, 1.0f}; /* default value */\n  glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);\n  glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);\n  glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);\n  glLightfv(GL_LIGHT0, GL_POSITION, light_position);\n  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lightModel_ambient);\n  glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);\n  glMaterialfv(GL_FRONT, GL_SPECULAR, material_specular);\n  glMaterialfv(GL_FRONT, GL_EMISSION, material_emission);\n  glMaterialf(GL_FRONT, GL_SHININESS, 10.0); /* NOT default value   */\n  glEnable(GL_LIGHTING);\n  glEnable(GL_LIGHT0);\n  glEnable(GL_NORMALIZE);\n  glEnable(GL_COLOR_MATERIAL);\n}\n\nvoid drawGameObject(GameObject* obj, bool useZBuffering) {\n  Vec3d pos, centroidOffset;\n  pos = obj->position;\n  centroidOffset = modelTypesProperties[obj->modelType].centroidOffset;\n\n  glPushMatrix();\n  glTranslatef(pos.x, pos.y, pos.z);\n  glRotatef(obj->rotation.y, 0, 1, 0);\n  glScalef(modelTypesProperties[obj->modelType].scale,\n           modelTypesProperties[obj->modelType].scale,\n           modelTypesProperties[obj->modelType].scale);\n\n  if (obj->modelType != NoneModel) {\n#if RENDERER_PAINTERS_ALGORITHM\n    if (useZBuffering) {\n      glEnable(GL_DEPTH_TEST);\n    } else {\n      glDisable(GL_DEPTH_TEST);\n    }\n#else\n    glEnable(GL_DEPTH_TEST);\n#endif\n#if USE_LIGHTING_STATIC_ONLY\n    if (Renderer_isLitGameObject(obj)) {\n      glEnable(GL_LIGHTING);\n    } else {\n      glDisable(GL_LIGHTING);\n    }\n#endif\n    drawModel(obj);\n  }\n  glPopMatrix();\n}\n\nvoid drawAABB(AABB* aabb) {\n  // top\n  glBegin(GL_LINE_LOOP);\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->min.z);\n  glEnd();\n\n  // bottom\n  glBegin(GL_LINE_LOOP);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->max.z);\n  glEnd();\n\n  // sides\n  glBegin(GL_LINES);\n  // 1\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->min.z);\n  // 2\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->max.z);\n  // 3\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->max.z);\n  // 4\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->min.z);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->min.z);\n  glEnd();\n}\n\nvoid drawAABBColored(AABB* aabb, float r, float g, float b) {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n  glColor3f(r, g, b);\n  drawAABB(aabb);\n  glPopAttrib();\n}\n\nvoid drawPlane(Plane* plane, Vec3d* up) {\n  glPushAttrib(GL_LIGHTING_BIT | GL_TEXTURE_BIT | GL_CURRENT_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n\n  Vec3d third;\n  Vec3d_cross(&plane->normal, up, &third);\n\n  glPushMatrix();\n  glTranslatef(plane->point.x, plane->point.y, plane->point.z);\n  drawMarker(0.5f * 0.8, 0.0f, 0.0f, 1);\n  glPopMatrix();\n\n  Vec3d normalScaled = plane->normal;\n  Vec3d_mulScalar(&normalScaled, 10);\n  Vec3d_add(&normalScaled, &plane->point);\n  glColor3f(0, 0, 1);\n  drawLine(&plane->point, &normalScaled);\n\n  Vec3d upScaled = *up;\n  Vec3d_mulScalar(&upScaled, 10);\n  Vec3d_add(&upScaled, &plane->point);\n  glColor3f(1, 0, 0);\n  drawLine(&plane->point, &upScaled);\n\n  Vec3d thirdScaled = third;\n  Vec3d_mulScalar(&thirdScaled, 10);\n  Vec3d_add(&thirdScaled, &plane->point);\n  glColor3f(0, 1, 0);\n  drawLine(&plane->point, &thirdScaled);\n\n  glPopAttrib();\n}\n\nvoid drawSpatialHashCell(int cellBaseX, int cellBaseY) {\n  AABB cellAABB;\n  cellAABB.min.x = SpatialHash_gridToUnitsForDimension(\n      cellBaseX, physWorldData.worldMeshSpatialHash);\n  cellAABB.min.y = 0;\n  cellAABB.min.z = -SpatialHash_gridToUnitsForDimension(\n      cellBaseY, physWorldData.worldMeshSpatialHash);\n  cellAABB.max.x = SpatialHash_gridToUnitsForDimension(\n      cellBaseX + 1, physWorldData.worldMeshSpatialHash);\n  cellAABB.max.y = 0;\n  cellAABB.max.z = -SpatialHash_gridToUnitsForDimension(\n      cellBaseY + 1, physWorldData.worldMeshSpatialHash);\n\n  drawAABBColored(&cellAABB, 1.0, 1.0, 0.0);\n}\n\nvoid spatialHashTraversalVisitor(int x, int y, void* traversalState) {\n  drawSpatialHashCell(x, y);\n}\n\nvoid drawCollisionMesh() {\n  int i;\n\n  Triangle* tri;\n  Vec3d triCentroid, triNormal;\n  char triIndexText[100];\n\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_DEPTH_BUFFER_BIT | GL_POLYGON_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n\n  // draw on top of everything else\n  glDisable(GL_DEPTH_TEST);\n\n  glPushMatrix();\n\n  // draw all tris wireframes\n  float triColor;\n  for (i = 0, tri = garden_map_collision_collision_mesh;\n       i < GARDEN_MAP_COLLISION_LENGTH; i++, tri++) {\n    triColor = (i / (float)GARDEN_MAP_COLLISION_LENGTH);\n    glColor3f(0.0f, triColor, 1.0f - triColor);\n    glBegin(GL_LINE_LOOP);\n    glVertex3f(tri->a.x, tri->a.y, tri->a.z);\n    glVertex3f(tri->b.x, tri->b.y, tri->b.z);\n    glVertex3f(tri->c.x, tri->c.y, tri->c.z);\n    glEnd();\n  }\n\n  // draw spatial hash matching tris\n  if (selectedObject) {\n    int spatialHashResults[100];\n    int spatialHashResultsCount;\n    Vec3d selectedObjCenter;\n    Game_getObjCenter(selectedObject, &selectedObjCenter);\n\n    spatialHashResultsCount = SpatialHash_getTriangles(\n        &selectedObjCenter, Game_getObjRadius(selectedObject),\n        physWorldData.worldMeshSpatialHash, spatialHashResults,\n        /*maxResults*/ 100);\n\n#if DEBUG_COLLISION_SPATIAL_HASH_RAYCAST\n    Vec3d testRayEnd = {0, 25, 0};\n    GameUtils_directionFromTopDownAngle(degToRad(selectedObject->rotation.y),\n                                        &testRayEnd);\n    Vec3d_mulScalar(&testRayEnd, 600);\n    Vec3d_add(&testRayEnd, &selectedObjCenter);\n\n    glColor3f(1.0f, 0.0f, 0.0f);  // red\n    drawLine(&selectedObjCenter, &testRayEnd);\n\n    // draw raycast in front of selected object\n    spatialHashResultsCount = SpatialHash_getTrianglesForRaycast(\n        &selectedObjCenter, &testRayEnd, physWorldData.worldMeshSpatialHash,\n        spatialHashResults,\n        /*maxResults*/ 1000);\n\n    // draw current cell\n    float cellBaseX = SpatialHash_unitsToGridFloatForDimension(\n        selectedObjCenter.x, physWorldData.worldMeshSpatialHash);\n    float cellBaseY = SpatialHash_unitsToGridFloatForDimension(\n        -selectedObjCenter.z, physWorldData.worldMeshSpatialHash);\n    // drawSpatialHashCell(cellBaseX, cellBaseY);\n    SpatialHash_raycast(cellBaseX, cellBaseY,\n                        SpatialHash_unitsToGridFloatForDimension(\n                            testRayEnd.x, physWorldData.worldMeshSpatialHash),\n                        SpatialHash_unitsToGridFloatForDimension(\n                            -testRayEnd.z, physWorldData.worldMeshSpatialHash),\n                        &spatialHashTraversalVisitor, (void*)NULL);\n#endif\n\n#if DEBUG_COLLISION_SPATIAL_HASH_TRIS\n    int i;\n    for (i = 0; i < spatialHashResultsCount; i++) {\n      glEnable(GL_BLEND);\n      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n      for (i = 0; i < spatialHashResultsCount; i++) {\n        tri = garden_map_collision_collision_mesh + spatialHashResults[i];\n        triColor = (spatialHashResults[i] / (float)GARDEN_MAP_COLLISION_LENGTH);\n\n        glColor4f(0.0f, triColor * 0.8, (1.0f - triColor) * 0.8, 0.3);\n        glBegin(GL_TRIANGLES);\n        glVertex3f(tri->a.x, tri->a.y, tri->a.z);\n        glVertex3f(tri->b.x, tri->b.y, tri->b.z);\n        glVertex3f(tri->c.x, tri->c.y, tri->c.z);\n        glEnd();\n      }\n      glDisable(GL_BLEND);\n    }\n#endif\n\n    // draw cells selected object is in\n    int minCellX = SpatialHash_unitsToGridForDimension(\n        selectedObjCenter.x - Game_getObjRadius(selectedObject),\n        physWorldData.worldMeshSpatialHash);\n    int minCellY = SpatialHash_unitsToGridForDimension(\n        -selectedObjCenter.z - Game_getObjRadius(selectedObject),\n        physWorldData.worldMeshSpatialHash);\n    int maxCellX = SpatialHash_unitsToGridForDimension(\n                       selectedObjCenter.x + Game_getObjRadius(selectedObject),\n                       physWorldData.worldMeshSpatialHash) +\n                   1;\n    int maxCellY = SpatialHash_unitsToGridForDimension(\n                       -selectedObjCenter.z + Game_getObjRadius(selectedObject),\n                       physWorldData.worldMeshSpatialHash) +\n                   1;\n\n    // draw overlapping cells\n    for (int cellX = minCellX; cellX < maxCellX; ++cellX) {\n      for (int cellY = minCellY; cellY < maxCellY; ++cellY) {\n        drawSpatialHashCell(cellX, cellY);\n      }\n    }\n\n#if DEBUG_COLLISION_MESH_AABB || DEBUG_COLLISION_SPATIAL_HASH_RAYCAST\n    for (i = 0; i < spatialHashResultsCount; i++) {\n      tri = garden_map_collision_collision_mesh + spatialHashResults[i];\n      AABB triangleAABB;\n      AABB_fromTriangle(tri, &triangleAABB);\n\n#if DEBUG_COLLISION_SPATIAL_HASH_RAYCAST\n      if (Collision_testSegmentAABBCollision(&selectedObjCenter, &testRayEnd,\n                                             &triangleAABB)) {\n        drawAABBColored(&triangleAABB, 1.0, 0.0, 0.0);  // red, collision\n      } else {\n        drawAABBColored(&triangleAABB, 1.0, 1.0, 0.0);  // yellow\n      }\n#else\n      drawAABBColored(&triangleAABB, 1.0, 1.0, 0.0);  // yellow\n#endif\n    }\n#endif\n  }\n\n  // draw collided tris\n  if (testCollisionResults.size()) {\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    std::map<int, SphereTriangleCollision>::iterator collIter =\n        testCollisionResults.begin();\n\n    while (collIter != testCollisionResults.end()) {\n      tri = garden_map_collision_collision_mesh + collIter->first;\n\n      if (testCollisionResult == collIter->first) {\n        glColor4f(1.0f, 0.0f, 0.0f, 0.3);\n      } else {\n        glColor4f(1.0f, 1.0f, 0.0f, 0.3);\n      }\n      glBegin(GL_TRIANGLES);\n      glVertex3f(tri->a.x, tri->a.y, tri->a.z);\n      glVertex3f(tri->b.x, tri->b.y, tri->b.z);\n      glVertex3f(tri->c.x, tri->c.y, tri->c.z);\n      glEnd();\n\n      collIter++;\n    }\n    glDisable(GL_BLEND);\n  }\n\n// draw tri labels & normals\n#if DEBUG_COLLISION_MESH_MORE\n  for (i = 0, tri = garden_map_collision_collision_mesh;\n       i < GARDEN_MAP_COLLISION_LENGTH; i++, tri++) {\n    triColor = (i / (float)GARDEN_MAP_COLLISION_LENGTH);\n    Triangle_getCentroid(tri, &triCentroid);\n    Triangle_getNormal(tri, &triNormal);\n\n    float triCollisionDistance = 0;\n    if (testCollisionResults.count(i) > 0) {\n      try {\n        SphereTriangleCollision& collisionTestResult =\n            testCollisionResults.at(i);\n\n        // marker showing closest hit point in triangle\n        Vec3d& hitPos = collisionTestResult.posInTriangle;\n        glPushMatrix();\n        glTranslatef(hitPos.x, hitPos.y, hitPos.z);\n        if (testCollisionResult == i) {\n          drawMarker(0.5f * 0.8, 0.0f, 0.0f, 1);\n        } else {\n          drawMarker(0.0f, triColor * 0.8, (1.0f - triColor) * 0.8, 1);\n        }\n        glPopMatrix();\n\n        // text label\n        triCollisionDistance = collisionTestResult.distance;\n        sprintf(triIndexText, \"%d: %.2f %s\", i, triCollisionDistance,\n                i == testCollisionResult ? \"[closest]\" : \"\");\n        drawStringAtPoint(triIndexText, &triCentroid, TRUE);\n      } catch (const std::out_of_range& oor) {\n        std::cerr << \"missing SphereTriangleCollision: \" << i << \"\\n\";\n      }\n    } else {\n      // print other tri indexes\n      sprintf(triIndexText, \"%d \", i);\n      drawStringAtPoint(triIndexText, &triCentroid, TRUE);\n    }\n\n    drawTriNormal(&triNormal, &triCentroid);\n  }\n#endif\n\n  glPopMatrix();\n  glPopAttrib();\n}\n\nvoid doTestPathfinding(int printResult) {\n  float profStartPath = CUR_TIME_MS();\n\n#if DEBUG_PATHFINDING_AUTO\n  Vec3d* goosePos = &Game_get()->player.goose->position;\n  Vec3d* characterPos = &Game_get()->characters->obj->position;\n  debugPathfindingTo = Path_quantizePosition(pathfindingGraph, goosePos);\n  debugPathfindingFrom = Path_quantizePosition(pathfindingGraph, characterPos);\n#else\n  debugPathfindingTo = CLAMP(debugPathfindingTo, 0, pathfindingGraph->size - 1);\n  debugPathfindingFrom =\n      CLAMP(debugPathfindingFrom, 0, pathfindingGraph->size - 1);\n#endif\n\n  Path_initState(\n      pathfindingGraph,                                          // graph\n      pathfindingState,                                          // state\n      Path_getNodeByID(pathfindingGraph, debugPathfindingFrom),  // start\n      Path_getNodeByID(pathfindingGraph, debugPathfindingTo),    // end\n      pathfindingState->nodeStates,     // nodeStates array\n      pathfindingState->nodeStateSize,  // nodeStateSize\n      pathfindingState->result          // results array\n  );\n\n  int result = Path_findAStar(pathfindingGraph, pathfindingState);\n\n  float profTimePath = (CUR_TIME_MS() - profStartPath);\n  Game_get()->profTimePath += profTimePath;\n\n  if (printResult) {\n    printf(\"finding path from %d to %d\\n\", pathfindingState->start->id,\n           pathfindingState->end->id);\n    printf(\"pathfinding result %s\\n\", result ? \"found\" : \"not found\");\n    printf(\"pathfinding took %f\\n\", profTimePath);\n    if (result) {\n      printf(\"pathfinding result length %d\\n\", pathfindingState->resultSize);\n\n      // pathfinding result path\n      for (int i = 0; i < pathfindingState->resultSize; i++) {\n        printf(\"%d: %d\\n\", i, *(pathfindingState->result + i));\n      }\n    }\n  }\n}\n\nvoid drawPathfindingGraph() {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n\n  Node* node;\n  Node* endNode;\n  Graph* graph = pathfindingGraph;\n  PathfindingState* state = pathfindingState;\n  int i, k;\n  int* reachedViaNodeID;\n\n  // draw graph edges\n  for (i = 0, node = graph->nodes;  //\n       i < graph->size;             //\n       i++, node++                  //\n  ) {\n    EdgeList* edges = Path_getNodeEdgesByID(graph, i);\n\n    // Loop through each edge in turn.\n    for (                                           //\n        k = 0, reachedViaNodeID = edges->elements;  //\n        k < edges->size;                            //\n        k++, reachedViaNodeID++                     //\n    ) {\n      endNode = Path_getNodeByID(graph, *reachedViaNodeID);\n      glColor3f(0.5f, 0.5f, 0.5f);  // grey\n      drawLine(&node->position, &endNode->position);\n    }\n  }\n\n  // draw pathfinding result path\n  for (i = 0;                      //\n       i < state->resultSize - 1;  //\n       i++                         //\n  ) {\n    node = Path_getNodeByID(graph, *(state->result + i));\n    endNode = Path_getNodeByID(graph, *(state->result + i + 1));\n\n    glColor3f(1.0f, 0.0f, 0.0f);  // red\n    drawLine(&node->position, &endNode->position);\n  }\n\n  // draw graph nodes\n  for (i = 0, node = graph->nodes;  //\n       i < graph->size;             //\n       i++, node++                  //\n  ) {\n    glPushMatrix();\n    glTranslatef(node->position.x, node->position.y, node->position.z);\n    glColor3f(1.0f, 0.7f, 0.0f);  // orange\n    glutSolidCube(10);\n    glPopMatrix();\n  }\n\n  for (i = 0, node = graph->nodes;  //\n       i < graph->size;             //\n       i++, node++                  //\n  ) {\n    drawStringAtPoint(std::to_string(i).c_str(), &node->position, TRUE);\n  }\n\n  Character* selectedCharacter = selectedObject == Game_get()->characters->obj\n                                     ? Game_get()->characters\n                                     : NULL;\n  if (selectedCharacter) {\n    glPushMatrix();\n    glTranslatef(selectedCharacter->targetLocation.x,\n                 selectedCharacter->targetLocation.y,\n                 selectedCharacter->targetLocation.z);\n    glColor3f(0.0f, 0.0f, 1.0f);  // blue\n    glutSolidCube(10);\n    glPopMatrix();\n    glPushMatrix();\n    glTranslatef(selectedCharacter->movementTarget.x,\n                 selectedCharacter->movementTarget.y,\n                 selectedCharacter->movementTarget.z);\n    glColor3f(1.0f, 0.0f, 0.0f);  // red\n    glutSolidCube(10);\n    glPopMatrix();\n  }\n\n  glPopAttrib();\n}\n\nvoid drawNodeGraph() {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n\n  Node* node;\n  Node* endNode;\n  int i;\n\n  // draw graph edges\n  for (auto edge = nodeGraph.edges.begin(); edge != nodeGraph.edges.end();\n       ++edge) {\n    node = &nodeGraph.nodes[edge->from];\n    endNode = &nodeGraph.nodes[edge->to];\n\n    glColor3f(0.5f, 0.5f, 0.5f);  // grey\n    drawLine(&node->position, &endNode->position);\n  }\n\n  // draw graph nodes\n  for (auto node = nodeGraph.nodes.begin(); node != nodeGraph.nodes.end();\n       ++node) {\n    glPushMatrix();\n    glTranslatef(node->position.x, node->position.y, node->position.z);\n    if (node->id == selectedNode) {\n      glColor3f(1.0f, 0.0f, 0.0f);  // red\n    } else {\n      glColor3f(1.0f, 0.7f, 0.0f);  // orange\n    }\n    glutSolidCube(10);\n    glPopMatrix();\n  }\n\n  // draw graph node ids\n  i = 0;\n  for (auto node = nodeGraph.nodes.begin(); node != nodeGraph.nodes.end();\n       ++node) {\n    drawStringAtPoint(std::to_string(i).c_str(), &node->position, TRUE);\n    i++;\n  }\n\n  glPopAttrib();\n}\n\nvoid renderScene(void) {\n  int i;\n  Game* game;\n\n  float profStartDraw = CUR_TIME_MS();\n\n  // Start the Dear ImGui frame\n  ImGui_ImplOpenGL2_NewFrame();\n  ImGui_ImplGLUT_NewFrame();\n\n  game = Game_get();\n\n#if RENDERER_FAKE_GROUND\n  glClearColor(112 / 255.0, 158 / 255.0, 122 / 255.0, 1);\n#else\n  glClearColor(0, 0, 0, 1);\n#endif\n\n  // Clear Color and Depth Buffers\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  // Use the Projection Matrix\n  glMatrixMode(GL_PROJECTION);\n  int w = glutGet(GLUT_WINDOW_WIDTH);\n  int h = glutGet(GLUT_WINDOW_HEIGHT);\n  float aspect = w / h;\n  resizeWindow(w, h);\n\n  // Reset transformations\n  glLoadIdentity();\n\n  // Set the camera\n  Frustum_setCamDef(&frustum, &game->viewPos, &game->viewTarget, &upVector);\n  if (game->freeView) {\n    gluLookAt(                                        //\n        freeViewPos.x, freeViewPos.y, freeViewPos.z,  // eye\n        freeViewPos.x + cameraLX, freeViewPos.y,\n        freeViewPos.z + cameraLZ,           // center\n        upVector.x, upVector.y, upVector.z  // up\n    );\n  } else {\n    gluLookAt(                                                       //\n        game->viewPos.x, game->viewPos.y, game->viewPos.z,           // eye\n        game->viewTarget.x, game->viewTarget.y, game->viewTarget.z,  // center\n        upVector.x, upVector.y, upVector.z                           // up\n    );\n  }\n\n  // store the viewport for later\n  glGetDoublev(GL_MODELVIEW_MATRIX, lastModelView);\n  glGetDoublev(GL_PROJECTION_MATRIX, lastProjection);\n  glGetIntegerv(GL_VIEWPORT, lastViewport);\n\n  int* worldObjectsVisibility =\n      (int*)malloc(game->worldObjectsCount * sizeof(int));\n  if (!worldObjectsVisibility) {\n    debugPrintf(\"failed to alloc worldObjectsVisibility\");\n  }\n\n  int visibilityCulled =\n      Renderer_cullVisibility(game->worldObjects, game->worldObjectsCount,\n                              worldObjectsVisibility, &frustum, localAABBs);\n  frustumCulled = visibilityCulled;\n\n  // only alloc space for num visible objects\n  int visibleObjectsCount = game->worldObjectsCount - visibilityCulled;\n  RendererSortDistance* visibleObjDist = (RendererSortDistance*)malloc(\n      (visibleObjectsCount) * sizeof(RendererSortDistance));\n  if (!visibleObjDist) {\n    debugPrintf(\"failed to alloc visibleObjDist\");\n  }\n  Renderer_sortVisibleObjects(\n      game->worldObjects, game->worldObjectsCount, worldObjectsVisibility,\n      visibleObjectsCount, visibleObjDist, &game->viewPos, garden_map_bounds);\n\n  // boolean of whether an object intersects another (for z buffer optimization)\n  int* intersectingObjects = (int*)malloc((visibleObjectsCount) * sizeof(int));\n  invariant(intersectingObjects);\n  Renderer_calcIntersecting(intersectingObjects, visibleObjectsCount,\n                            visibleObjDist, garden_map_bounds);\n\n#if USE_LIGHTING\n  enableLighting();\n#endif\n\n#if USE_FLAT_SHADING\n  glShadeModel(GL_FLAT);\n#endif\n\n#if DEBUG_LOG_RENDER\n  printf(\"draw start\\n\");\n#endif\n  // render visible objects\n  for (i = 0; i < visibleObjectsCount; i++) {\n    GameObject* obj = (visibleObjDist + i)->obj;\n#if DEBUG_LOG_RENDER\n    printf(\"draw obj %d %s dist=%.3f {x:%.3f, y:%.3f, z:%.3f}\\n\", obj->id,\n           ModelTypeStrings[obj->modelType],\n           Vec3d_distanceTo(&(obj->position), &viewPos), obj->position.x,\n           obj->position.y, obj->position.z);\n#endif\n    drawGameObject(\n        obj,\n        // useZBuffering\n        intersectingObjects[i] ||\n            // animated game objects have concave shapes, need z buffering\n            Renderer_isAnimatedGameObject(obj)\n\n    );\n  }\n\n#if USE_SPRITES\n\n  // draw sprite attachments\n  for (i = 0; i < visibleObjectsCount; i++) {\n    GameObject* obj = (visibleObjDist + i)->obj;\n\n    if (obj->animState) {\n      AnimationBoneSpriteAttachment& sprAttachment =\n          obj->animState->spriteAttachment;\n\n      drawSpriteAtPoint(sprAttachment.spriteType, 0, 100, 100, &obj->position,\n                        TRUE);\n    }\n  }\n#endif\n\n#if USE_LIGHTING\n  glEnable(GL_LIGHTING);\n#endif\n#if USE_FLAT_SHADING\n  glShadeModel(GL_SMOOTH);\n#endif\n\n#if DEBUG_COLLISION_MESH || DEBUG_COLLISION_MESH_MORE || \\\n    DEBUG_COLLISION_SPATIAL_HASH || DEBUG_COLLISION_MESH_AABB\n  drawCollisionMesh();\n#endif\n\n#if DEBUG_AABB\n  for (i = 0; i < game->worldObjectsCount; i++) {\n    GameObject* obj = game->worldObjects + i;\n    AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n    drawAABBColored(&worldAABB, 0.8, 0.8, 0.8);\n\n#if DEBUG_FRUSTUM\n    FrustumTestResult frustumTestResult;\n    if (frustumPlaneToTest > -1) {\n      Vec3d vertexP, vertexN;\n      Frustum_getAABBVertexP(\n          &worldAABB, &frustum.planes[frustumPlaneToTest].normal, &vertexP);\n      Frustum_getAABBVertexN(\n          &worldAABB, &frustum.planes[frustumPlaneToTest].normal, &vertexN);\n      frustumTestResult = Frustum_boxFrustumPlaneTestPN(&frustum, &worldAABB,\n                                                        frustumPlaneToTest);\n      glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n                   GL_POLYGON_BIT);\n      glDisable(GL_DEPTH_TEST);\n      glDisable(GL_LIGHTING);\n      glDisable(GL_TEXTURE_2D);\n      // glDisable(GL_CULL_FACE);\n\n      glPushMatrix();\n      glTranslatef(vertexP.x, vertexP.y, vertexP.z);\n      glColor3f(1.0, 0.0, 0.0);\n      glutSolidCube(2);\n      glPopMatrix();\n\n      glPushMatrix();\n      glTranslatef(vertexN.x, vertexN.y, vertexN.z);\n      glColor3f(0.0, 1.0, 0.0);\n      glutSolidCube(2);\n      glPopMatrix();\n    } else {\n      frustumTestResult = Frustum_boxInFrustum(&frustum, &worldAABB);\n    }\n    drawStringAtPoint(FrustumTestResultStrings[frustumTestResult],\n                      &obj->position, TRUE);\n\n#endif\n  }\n#endif\n\n#if DEBUG_PAINTERS_ALGORITHM_SEPARATING_PLANE\n  if (selectedObject) {\n    GameObject* a = game->player.goose;\n    GameObject* b = selectedObject;\n    Plane separatingPlane;\n    Vec3d aCenter, bCenter, aClosestPoint, bClosestPoint, aReallyClosestPoint,\n        bReallyClosestPoint;\n    AABB aabbA = Renderer_getWorldAABB(localAABBs, a);\n    AABB aabbB = Renderer_getWorldAABB(localAABBs, b);\n    float planeToADist, planeToViewDist;\n    Game_getObjCenter(a, &aCenter);\n    Game_getObjCenter(b, &bCenter);\n    if (Renderer_isDynamicObject(a)) {\n      aClosestPoint = aCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbA, &bCenter, &aClosestPoint);\n    }\n    if (Renderer_isDynamicObject(b)) {\n      bClosestPoint = bCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbB, &aCenter, &bClosestPoint);\n    }\n\n    if (Renderer_isDynamicObject(a)) {\n      aReallyClosestPoint = aCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbA, &bClosestPoint, &aReallyClosestPoint);\n    }\n    if (Renderer_isDynamicObject(b)) {\n      bReallyClosestPoint = bCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbB, &aClosestPoint, &bReallyClosestPoint);\n    }\n\n    Renderer_getSeparatingPlane(&aReallyClosestPoint, &bReallyClosestPoint,\n                                &separatingPlane);\n\n    drawPlane(&separatingPlane, &upVector);\n    drawMotionVectorLine(&aReallyClosestPoint, &bReallyClosestPoint);\n\n    drawMotionVectorLine(&aCenter, &separatingPlane.point);\n\n    drawTriNormal(&separatingPlane.normal, &separatingPlane.point);\n\n    Vec3d closestPointOnPlane;\n    Plane_pointClosestPoint(&separatingPlane, &aReallyClosestPoint,\n                            &closestPointOnPlane);\n    drawMarkerAtPoint(1, 1, 0, 1, &closestPointOnPlane);\n  }\n\n#endif\n\n#if DEBUG_ZBUFFER_INTERSECTING\n  {\n    for (int i = 0; i < visibleObjectsCount; ++i) {\n      GameObject* obj = (visibleObjDist + i)->obj;\n      AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n\n      drawAABBColored(&worldAABB, 0.8, 0.8, 0.8);  // grey\n      drawStringAtPoint(\n          intersectingObjects[i] ? \"ZB:Intersecting\" : \"ZB:Disjoint\",\n          &obj->position, TRUE);\n    }\n  }\n#endif\n\n#if DEBUG_PHYSICS\n  PhysBody* body;\n  for (i = 0, body = game->physicsBodies; i < game->physicsBodiesCount;\n       i++, body++) {\n    glPushMatrix();\n    glTranslatef(body->position.x, body->position.y, body->position.z);\n    drawPhysBall(body->radius);\n    glPopMatrix();\n    drawMotionVectorLine(&body->prevPosition, &body->position);\n  }\n#endif\n\n#if DEBUG_RAYCASTING\n  for (i = 0; i < gameRaycastTrace.size(); ++i) {\n    drawRaycastLine(gameRaycastTrace[i]);\n  }\n\n#endif\n  gameRaycastTrace.clear();\n\n#if DEBUG_PATHFINDING_GRAPH\n  drawPathfindingGraph();\n#endif\n#if ENABLE_NODEGRAPH_EDITOR\n  drawNodeGraph();\n#endif\n\n#if DEBUG_FRUSTUM\n  glPushMatrix();\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_POLYGON_BIT);\n  // glEnable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_CULL_FACE);\n  Frustum_drawPoints(&frustum);\n  Frustum_drawLines(&frustum);\n  Frustum_drawPlanes(&frustum);\n\n  glPopMatrix();\n  glPopAttrib();\n#endif\n\n#if DEBUG_OBJECTS\n  char objdebugtext[300];\n  for (i = 0; i < game->worldObjectsCount; i++) {\n    GameObject* obj = game->worldObjects + i;\n    strcpy(objdebugtext, \"\");\n\n    sprintf(objdebugtext, \"%d: %s\", obj->id, ModelTypeStrings[obj->modelType]);\n\n    drawStringAtPoint(objdebugtext, &obj->position, TRUE);\n\n    Vec3d objCenter;\n    Game_getObjCenter(obj, &objCenter);\n\n    glPushMatrix();\n    glTranslatef(objCenter.x, objCenter.y, objCenter.z);\n    drawMarker(0.2, 0.2, 0.2, Game_getObjRadius(obj));\n    glPopMatrix();\n  }\n#endif\n\n  if (selectedObject) {\n    Vec3d selObjCenter;\n    Game_getObjCenter(selectedObject, &selObjCenter);\n\n    glPushMatrix();\n    glTranslatef(selObjCenter.x, selObjCenter.y, selObjCenter.z);\n    drawMarker(1.0, 0.5, 0.0, Game_getObjRadius(selectedObject));\n    glPopMatrix();\n  }\n\n  char pausedtext[80];\n  if (game->paused) {\n    strcpy(pausedtext, \"paused\");\n    drawString(pausedtext, w / 2 - strlen(pausedtext) / 2, h / 2);\n  }\n\n#if DEBUG_TEXT_BASIC\n  char debugtext[80];\n  Vec3d_toString(&game->player.goose->position, debugtext);\n  drawString(debugtext, 20, 20);\n\n  char characterString[120];\n  Character* character;\n  for (i = 0, character = game->characters; i < game->charactersCount;\n       i++, character++) {\n    Character_toString(character, characterString);\n    drawString(characterString, 20, glutGet(GLUT_WINDOW_HEIGHT) - 40 * (i + 1));\n  }\n  i++;\n  Player_toString(&game->player, characterString);\n  drawString(characterString, 20, glutGet(GLUT_WINDOW_HEIGHT) - 40 * (i + 1));\n#endif\n\n#if ENABLE_NODEGRAPH_EDITOR\n  drawString(\"NodeGraph Editor Mode\", 20, glutGet(GLUT_WINDOW_HEIGHT) - 20);\n#endif\n\n  // Imgui Rendering\n  drawGUI();\n  ImGui::Render();\n  ImGuiIO& io = ImGui::GetIO();\n  ImGui_ImplOpenGL2_RenderDrawData(ImGui::GetDrawData());\n\n  free(intersectingObjects);\n  free(visibleObjDist);\n  free(worldObjectsVisibility);\n\n  game->profTimeDraw += (CUR_TIME_MS() - profStartDraw);\n  glutSwapBuffers();\n}\n\nvoid updateCameraAngle(float newAngle) {\n  cameraAngle = newAngle;\n  cameraLX = sin(cameraAngle);\n  cameraLZ = -cos(cameraAngle);\n}\n\nvoid turnLeft() {\n  updateCameraAngle(cameraAngle - 0.01f);\n}\n\nvoid turnRight() {\n  updateCameraAngle(cameraAngle + 0.01f);\n}\n\nvoid moveForward() {\n  freeViewPos.x += cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z += cameraLZ * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveBack() {\n  freeViewPos.x -= cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z -= cameraLZ * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveLeft() {\n  freeViewPos.x -= cameraLZ * -FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z -= cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveRight() {\n  freeViewPos.x += cameraLZ * -FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z += cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveUp() {\n  freeViewPos.y += FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveDown() {\n  freeViewPos.y -= FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid updateFreeView() {\n  Game* game;\n  game = Game_get();\n\n  for (int key = 0; key < 127; ++key) {\n    if (keysDown[key]) {\n      if (game->freeView && !enableControlsInFreeView) {\n        switch (key) {\n          case 97:  // a\n            moveLeft();\n            break;\n          case 100:  // d\n            moveRight();\n            break;\n          case 119:  // w\n            moveForward();\n            break;\n          case 115:  // s\n            moveBack();\n            break;\n          case 113:  // q\n            turnLeft();\n            break;\n          case 101:  // e\n            turnRight();\n            break;\n          case 114:  // r\n            moveUp();\n            break;\n          case 102:  // f\n            moveDown();\n            break;\n        }\n      }\n\n      if (key == 99 && glgooseFrame % 10 == 0) {  // c\n        game->freeView = !game->freeView;\n        if (game->freeView) {\n          printf(\"changing to freeview\\n\");\n        } else {\n          printf(\"changing from freeview\\n\");\n        }\n      }\n    }\n  }\n}\n\nvoid updateInputs() {\n  Game* game;\n  game = Game_get();\n\n  for (int key = 0; key < 127; ++key) {\n    if (keysDown[key]) {\n      if (!game->freeView || enableControlsInFreeView) {\n        switch (key) {\n          case 113:  // q\n            input.zoomIn = TRUE;\n            break;\n          case 101:  // e\n            input.zoomOut = TRUE;\n            break;\n          case 97:  // a\n            input.direction.x += 1.0;\n            break;\n          case 100:  // d\n            input.direction.x -= 1.0;\n            break;\n          case 119:  // w\n            input.direction.y += 1.0;\n            break;\n          case 115:  // s\n            input.direction.y -= 1.0;\n            break;\n          case 32:  // space\n            input.pickup = true;\n            break;\n          case 118:  // v\n            input.run = true;\n            break;\n        }\n      }\n\n      if (key == 112 && glgooseFrame % 10 == 0) {  // p\n        game->paused = !game->paused;\n      }\n    }\n  }\n}\n\nvoid quit(int exitCode) {\n  ImGui_ImplOpenGL2_Shutdown();\n  ImGui_ImplGLUT_Shutdown();\n  ImGui::DestroyContext();\n  exit(exitCode);\n}\n\nvoid processNormalKeysUp(unsigned char key, int _x, int _y) {\n  ImGui_ImplGLUT_KeyboardUpFunc(key, _x, _y);\n  if (ImGui::GetIO().WantCaptureKeyboard) {\n    return;\n  }\n\n  keysDown[key] = false;\n}\n\nvoid processNormalKeysDown(unsigned char key, int _x, int _y) {\n  ImGui_ImplGLUT_KeyboardFunc(key, _x, _y);\n  if (ImGui::GetIO().WantCaptureKeyboard) {\n    return;\n  }\n\n  keysDown[key] = true;\n\n  if (key == 27) {  // esc\n    quit(0);\n  }\n}\n\nvoid selectObjectAtScreenPos(int x, int y) {\n  Vec3d mouseScreenPos0, mouseScreenPos1;\n  Vec3d raySource, rayTarget, rayDirection;\n  int invY = lastViewport[3] - y;\n\n  // near end, ray origin\n  Vec3d_init(&mouseScreenPos0, x, invY, 0.0f);\n  screenCoordsToWorld(&mouseScreenPos0, &raySource);\n\n  // far end\n  GLfloat depth;\n  glReadPixels(x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &depth);\n  Vec3d_init(&mouseScreenPos1, x, invY, depth);\n  screenCoordsToWorld(&mouseScreenPos1, &rayTarget);\n\n  // ray direction\n  Vec3d_directionTo(&raySource, &rayTarget, &rayDirection);\n\n#if ENABLE_NODEGRAPH_EDITOR\n  selectedNode = -1;\n  for (auto node = nodeGraph.nodes.begin(); node != nodeGraph.nodes.end();\n       ++node) {\n    if (Game_rayIntersectsSphere(&raySource, &rayDirection, &node->position,\n                                 10)) {\n      selectedNode = node->id;\n      break;\n    }\n  }\n#else\n  selectedObject = Game_getIntersectingObject(&raySource, &rayDirection);\n#endif\n}\n\nvoid processMouse(int button, int state, int x, int y) {\n  ImGui_ImplGLUT_MouseFunc(button, state, x, y);\n  if (ImGui::GetIO().WantCaptureMouse) {\n    return;\n  }\n\n  if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {\n    selectObjectAtScreenPos(x, y);\n  }\n}\n\nvoid testCollision() {\n  if (selectedObject) {\n    Vec3d objCenter;\n    Game_getObjCenter(selectedObject, &objCenter);\n    float objRadius = Game_getObjRadius(selectedObject);\n    SphereTriangleCollision result;\n    testCollisionTrace = TRUE;\n    Collision_testMeshSphereCollision(\n        garden_map_collision_collision_mesh, GARDEN_MAP_COLLISION_LENGTH,\n        &objCenter, objRadius, physWorldData.worldMeshSpatialHash, &result);\n    testCollisionTrace = FALSE;\n  } else {\n    testCollisionResult = -1;\n    testCollisionResults.clear();\n  }\n}\n\nvoid updateAndRender() {\n  Game* game;\n  game = Game_get();\n\n  glgooseFrame++;\n  updateFreeView();\n  if (glgooseFrame % updateSkipRate == 0) {\n    updateInputs();\n\n    if (game->tick % 60 == 0) {\n      profAvgCharacters = game->profTimeCharacters / 60.0f;\n      game->profTimeCharacters = 0.0f;\n      profAvgPhysics = game->profTimePhysics / 60.0f;\n      game->profTimePhysics = 0.0f;\n      profAvgDraw = game->profTimeDraw / 60.0f;\n      game->profTimeDraw = 0.0f;\n      profAvgPath = game->profTimePath / 60.0f;\n      game->profTimePath = 0.0f;\n    }\n\n#if DEBUG_COLLISION_MESH\n    testCollision();\n#endif\n#if DEBUG_PATHFINDING\n    // doTestPathfinding(FALSE);\n#endif\n\n    Game_update(&input);\n  }\n\n  renderScene();\n}\n\nint main(int argc, char** argv) {\n  int i;\n\n  Game* game;\n  GameObject* obj;\n\n  Game_init(garden_map_data, GARDEN_MAP_COUNT, &physWorldData);\n\n  game = Game_get();\n  game->pathfindingGraph = pathfindingGraph;\n  game->pathfindingState = pathfindingState;\n\n  freeViewPos = game->player.goose->position;\n  freeViewPos.x += 10;\n  freeViewPos.z += 10;\n\n  Input_init(&input);\n\n  updateCameraAngle(180);\n\n  for (i = 0, obj = game->worldObjects; i < game->worldObjectsCount;\n       i++, obj++) {\n    printf(\"loaded obj %d %s  {x:%.3f, y:%.3f, z:%.3f}\\n\", obj->id,\n           ModelTypeStrings[obj->modelType], obj->position.x, obj->position.y,\n           obj->position.z);\n  }\n\n  invariant(GARDEN_MAP_COUNT <= MAX_WORLD_OBJECTS);\n\n  // init GLUT and create window\n  glutInit(&argc, argv);\n  glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA | GLUT_MULTISAMPLE);\n  glutInitWindowPosition(300, 100);\n  glutInitWindowSize(1920, 1200);\n  glutCreateWindow(\"Goose\");\n\n  // register callbacks\n  glutDisplayFunc(renderScene);\n  glutIdleFunc(updateAndRender);\n\n  // Setup Dear ImGui context\n  IMGUI_CHECKVERSION();\n  ImGui::CreateContext();\n  ImGuiIO& io = ImGui::GetIO();\n  (void)io;\n  // io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable\n  // Keyboard Controls\n\n  // Setup Dear ImGui style\n  ImGui::StyleColorsDark();\n  // ImGui::StyleColorsClassic();\n\n  // Setup Platform/Renderer bindings\n  ImGui_ImplGLUT_Init();\n  ImGui_ImplGLUT_InstallFuncs();\n  ImGui_ImplOpenGL2_Init();\n\n  // replace some handlers after ImGui_ImplGLUT_InstallFuncs() sets its own\n  // our impls will call the Imgui impls internally\n  glutReshapeFunc(resizeWindow);\n  glutKeyboardFunc(processNormalKeysDown);\n  glutKeyboardUpFunc(processNormalKeysUp);\n  glutMouseFunc(processMouse);\n\n  // OpenGL init\n  glEnable(GL_DEPTH_TEST);\n  glEnable(GL_CULL_FACE);\n\n  // Load models. This has to be after OpenGL init because it creates textures\n  loadModel(GooseModel, \"gooserig.obj\", \"goosetex.bmp\");\n  loadModel(UniFloorModel, \"garden_floor.obj\", \"green.bmp\");\n  loadModel(UniBldgModel, \"garden_bldg.obj\", \"redbldg.bmp\");\n  loadModel(BushModel, \"bush.obj\", \"bush.bmp\");\n  loadModel(FlagpoleModel, \"flagpole.obj\", \"flagpole.bmp\");\n  loadModel(GardenerCharacterModel, \"characterrig.obj\", \"person.bmp\");\n  loadModel(BookItemModel, \"book.obj\", \"book.bmp\");\n  loadModel(HomeworkItemModel, \"testingCube.obj\", \"testCubeTex.bmp\");\n  loadModel(WallModel, \"wall.obj\", \"wall.bmp\");\n  loadModel(PlanterModel, \"planter.obj\", \"planter.bmp\");\n  loadModel(GroundModel, \"ground.obj\", \"gardengrass.bmp\");\n  loadModel(WaterModel, \"water.obj\", \"water.bmp\");\n  loadModel(RockModel, \"rocks.obj\", \"rock.bmp\");\n  loadModel(WatergrassModel, \"watergrass.obj\", \"watergrass.bmp\");\n  loadModel(ReedModel, \"reed.obj\", \"reed.bmp\");\n  loadModel(LilypadModel, \"lilypad.obj\", \"lilypad.bmp\");\n\n  loadSprite(NoneSprite, {\"testspr.bmp\"});\n  // loadSprite(HonkSprite, {\"honk1spr.bmp\", \"honk2spr.bmp\", \"honk3spr.bmp\"});\n\n#if ENABLE_NODEGRAPH_EDITOR\n  nodeGraph.load(pathfindingGraph);\n#endif\n\n  // enter GLUT event processing cycle\n  glutMainLoop();\n\n  quit(1);\n}\n",
			"file": "glgoose.cpp",
			"file_size": 78195,
			"file_write_time": 132334598076050210,
			"settings":
			{
				"buffer_size": 78195,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"file": "graphic.c",
			"settings":
			{
				"buffer_size": 9094,
				"line_ending": "Windows"
			}
		},
		{
			"file": "renderer.c",
			"settings":
			{
				"buffer_size": 11937,
				"line_ending": "Unix"
			}
		},
		{
			"file": "renderer.h",
			"settings":
			{
				"buffer_size": 2143,
				"line_ending": "Unix"
			}
		},
		{
			"file": "frustum.h",
			"settings":
			{
				"buffer_size": 2119,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "spec",
			"settings":
			{
				"buffer_size": 2630,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Makefile",
			"settings":
			{
				"buffer_size": 1068,
				"line_ending": "Windows"
			}
		},
		{
			"file": "build_cached.sh",
			"settings":
			{
				"buffer_size": 297,
				"line_ending": "Unix"
			}
		},
		{
			"file": "build.sh",
			"settings":
			{
				"buffer_size": 77,
				"line_ending": "Unix"
			}
		},
		{
			"file": "frustum.c",
			"settings":
			{
				"buffer_size": 14164,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "vec3d.c",
			"settings":
			{
				"buffer_size": 3464,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Emu Build",
					""
				],
				[
					"GL Build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/SublimeREPL/sublimerepl_build_system_hack.sublime-build",
					""
				]
			],
			[
				"GL Build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 271.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"edit",
				"Project: Edit Project"
			],
			[
				"re",
				"File: Rename"
			],
			[
				"ren",
				"File: Rename"
			],
			[
				"makef",
				"Set Syntax: Makefile"
			],
			[
				"clan",
				"Clang Format: Format Selection"
			],
			[
				"snak",
				"Convert Case: snake_case"
			],
			[
				"snake",
				"Convert Case: snake_case"
			],
			[
				"goto",
				"SublimeLinter: Goto Error"
			],
			[
				"editpr",
				"Project: Edit Project"
			],
			[
				"setting",
				"Preferences: Settings"
			],
			[
				"format",
				"Clang Format: Format Selection"
			],
			[
				"syn c",
				"Set Syntax: C"
			],
			[
				"sync",
				"Set Syntax: C"
			],
			[
				"sor",
				"Sort Lines"
			],
			[
				"form",
				"JsPrettier: Format Code"
			],
			[
				"sublimelinter",
				"Preferences: SublimeLinter Settings"
			],
			[
				"path",
				"File: Copy Path"
			],
			[
				"close",
				"File: Close All"
			],
			[
				"projec",
				"Project: Edit"
			],
			[
				"del",
				"File: Delete"
			],
			[
				"name",
				"File: Copy Name"
			],
			[
				"upper",
				"Convert Case: Upper Case"
			],
			[
				"came",
				"Convert Case: camelCase"
			],
			[
				"schem",
				"Schemr: List all schemes"
			],
			[
				"theme",
				"Themr: List themes"
			],
			[
				"jav",
				"Set Syntax: JavaScript"
			],
			[
				"them",
				"Themr: List themes"
			],
			[
				"scheme",
				"Schemr: List all schemes"
			],
			[
				"key",
				"Preferences: Key Bindings"
			],
			[
				"keyb",
				"Preferences: Key Bindings"
			],
			[
				"dele",
				"File: Delete"
			],
			[
				"c addre",
				"Snippet: c addressof"
			],
			[
				"",
				":0 - BOF"
			],
			[
				"new snipp",
				"PackageDev: New Raw Snippet"
			],
			[
				"pack oin",
				"Package Control: Install Package"
			],
			[
				"low",
				"Convert Case: Lower Case"
			],
			[
				"forma",
				"JsPrettier: Format Code"
			],
			[
				"c++",
				"Set Syntax: C++"
			],
			[
				"prefere",
				"Preferences: Settings"
			],
			[
				"packin",
				"Package Control: Install Package"
			],
			[
				"sort",
				"Sort Lines"
			],
			[
				"err",
				"SublimeLinter: Goto Error"
			],
			[
				"linter",
				"SublimeLinter: Goto Error"
			],
			[
				"jasv",
				"Set Syntax: JavaScript"
			],
			[
				"got",
				"SublimeLinter: Goto Error"
			],
			[
				"Dele",
				"File: Delete"
			],
			[
				"wrap",
				"Word Wrap: Toggle"
			],
			[
				"upp",
				"Convert Case: Upper Case"
			],
			[
				"wra",
				"Word Wrap: Toggle"
			],
			[
				"s",
				"Sort Lines"
			],
			[
				"uni",
				"Permute Lines: Unique"
			],
			[
				"disable",
				"Package Control: Disable Package"
			],
			[
				"renam",
				"Rename File"
			],
			[
				"linterset",
				"Preferences: SublimeLinter Settings"
			],
			[
				"debug",
				"BracketHighlighter: Enable Debug Mode"
			],
			[
				"brak",
				"BracketHighlighter: Toggle Global Enable"
			],
			[
				"brakethigh",
				"BracketHighlighter: Toggle Global Enable"
			],
			[
				"match",
				"BracketHighlighter: Match Brackets (ignore threshold)"
			],
			[
				"cam",
				"Convert Case: camelCase"
			],
			[
				"scame",
				"Convert Case: camelCase"
			],
			[
				"error",
				"SublimeLinter: Goto Error"
			],
			[
				"de",
				"File: Delete"
			],
			[
				"pyth",
				"Set Syntax: Python"
			],
			[
				"bui",
				"Build With: Emu Build"
			],
			[
				"build",
				"Build With: Emu Build"
			],
			[
				"javc",
				"Set Syntax: JavaScript"
			],
			[
				"synbash",
				"Set Syntax: Bourne Again Shell (bash)"
			],
			[
				"preferlint",
				"Preferences: SublimeLinter Settings"
			],
			[
				"pro",
				"Project: Edit"
			],
			[
				"preferelint",
				"Preferences: SublimeLinter Settings"
			],
			[
				"prefer",
				"Preferences: Settings"
			],
			[
				"Synct",
				"Set Syntax: C++"
			],
			[
				"syn++",
				"Set Syntax: C++"
			],
			[
				"move",
				"File: Move"
			],
			[
				"dle",
				"File: Delete"
			],
			[
				"clang",
				"Clang Format: Select Style"
			],
			[
				"brow",
				"Preferences: Browse Packages"
			],
			[
				"disabl",
				"Package Control: Disable Package"
			],
			[
				"buildview",
				"Disable/Enable buildview for this window"
			],
			[
				"buildgl",
				"Build With: GL Build"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"gl bu",
				"Build With: GL Build"
			],
			[
				"rean",
				"File: Rename"
			],
			[
				"sublimelint",
				"Preferences: SublimeLinter Settings"
			],
			[
				"sublimelin",
				"Preferences: SublimeLinter Settings"
			],
			[
				"syntaxc",
				"Set Syntax: C"
			],
			[
				"perma",
				"GitHubinator Permalink"
			],
			[
				"githu",
				"GitHubinator"
			],
			[
				"pac",
				"Package Control: Install Package"
			],
			[
				"pasca",
				"Convert Case: PascalCase"
			],
			[
				"cap",
				"Convert Case: PascalCase"
			],
			[
				"sche",
				"Schemr: List all schemes"
			],
			[
				"sch",
				"Schemr: List all schemes"
			],
			[
				"sett",
				"Preferences: Settings"
			],
			[
				"prefe",
				"Preferences: Settings"
			],
			[
				"dup",
				"File: Duplicate"
			],
			[
				"prett",
				"Preferences: JsPrettier Settings - Default"
			],
			[
				"pret",
				"Preferences: JsPrettier Settings - User"
			],
			[
				"prettier",
				"JsPrettier: Format Code"
			],
			[
				"pre",
				"Preferences: JsPrettier Settings - User"
			],
			[
				"json",
				"Set Syntax: JSON"
			],
			[
				"flow",
				"GitHub Flavored Markdown: Preview"
			],
			[
				"enable",
				"Package Control: Enable Package"
			],
			[
				"pl",
				"Package Control: List Packages"
			],
			[
				"lintthis",
				"SublimeLinter: Lint This View"
			],
			[
				"lint",
				"File: New View into File"
			],
			[
				"lintersett",
				"Preferences: SublimeLinter Settings"
			],
			[
				"linters",
				"Preferences: SublimeLinter Settings"
			],
			[
				"enablepack",
				"Package Control: Enable Package"
			],
			[
				"list linter",
				"SublimeLinter: Reload SublimeLinter and its Plugins"
			],
			[
				"sublimelintesett",
				"Preferences: SublimeLinter Settings"
			],
			[
				"sublimeLinter sett",
				"Preferences: SublimeLinter Settings"
			],
			[
				"lin",
				"SublimeLinter: Lint This View"
			],
			[
				"erro",
				"SublimeLinter: Goto Error"
			],
			[
				"go",
				"SublimeLinter: Goto Error"
			],
			[
				"unfo",
				"Code Folding: Unfold All"
			],
			[
				"unfor",
				"SublimeREPL: SBT for opened folder"
			],
			[
				"sublimlintset",
				"Preferences: SublimeLinter Settings"
			],
			[
				"pretter",
				"Preferences: JsPrettier Settings - User"
			],
			[
				"new view",
				"File: New View into File"
			],
			[
				"tag",
				"Tag: Remove Picked Tags in Document"
			],
			[
				"tag remove",
				"Tag: Remove Picked Tags in Document"
			],
			[
				"musta",
				"Set Syntax: HTML with mustaches"
			],
			[
				"conver",
				"Convert Case: dash-case"
			],
			[
				"reason",
				"Set Syntax: Reason"
			],
			[
				"dl",
				"File: Delete"
			],
			[
				"for",
				"Reason: Format file"
			],
			[
				"fork",
				"GitHub Flavored Markdown: Preview"
			]
		],
		"width": 496.0
	},
	"console":
	{
		"height": 471.0,
		"history":
		[
			"view.scope_name(view.sel()[0].begin())",
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)",
			"import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print('Please restart Sublime Text to finish installation')"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/jfriend/.wine/drive_c/goose64"
	],
	"file_history":
	[
		"/Users/jfriend/.wine/drive_c/goose64/GNUmakefile",
		"/Users/jfriend/.wine/drive_c/goose64/goose64glut.sublime-project",
		"/Users/jfriend/.wine/drive_c/goose64/Makefile.modern",
		"/Users/jfriend/.wine/drive_c/goose64/build.sh",
		"/Users/jfriend/.wine/drive_c/goose64/stage00.c",
		"/Users/jfriend/.wine/drive_c/goose64/rotation.c",
		"/Users/jfriend/.wine/drive_c/goose64/gl/texture.cpp",
		"/Users/jfriend/.wine/drive_c/goose64/gl/objloader.hpp",
		"/Users/jfriend/.wine/drive_c/goose64/constants.h",
		"/Users/jfriend/.wine/drive_c/goose64/ed64io_usb.c",
		"/Users/jfriend/.wine/drive_c/goose64/ed64io_sys.c",
		"/Users/jfriend/.wine/drive_c/goose64/glgoose.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/nodegraph/nodegraph.hpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/university_map_collision.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/main.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/glgoose.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/stage00.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/pathfinding.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/game.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/character.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/NOTES.md",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/README.md",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gametypes.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/game.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gameobject.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/item.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/character.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/characterstate.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/pathfinding.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/book.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/constants.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/characterstate.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io_errors.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io_sys.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io_sys.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io_everdrive.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io_everdrive.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/goose64.sublime-project",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io_usb.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io_usb.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/build.sh",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/.gitignore",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/compile.bat",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/modeltype.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/modeltype.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/university_map.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/rotation.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/vec2d.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/Makefile",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/physics.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/physics.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/physics.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/deploy.sh",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/triangleraster.js",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/triangleraster.html",
		"/Users/jfriend/code/ed64log/make.sh",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/wavefront64/wavefront64deps/util.lua",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io/usb.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io/everdrive.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io/sys.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io/everdrive.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io/sys.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ed64io/usb.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/bush.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/wall.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/university_map_collision.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/export_collision_mesh.py",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/spatial_hash.py",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/university_map_collision.json",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/collision.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/collision.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/export_character_model.py",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/rotation.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/animation.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/vec3d.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/vec3d.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/export_object_model.py",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/characterrig.h",
		"/Users/jfriend/Library/Application Support/Sublime Text 3/Packages/User/c addressof.sublime-snippet",
		"/Users/jfriend/Library/Application Support/Sublime Text 3/Packages/User/c.sublime-completions",
		"/Users/jfriend/Library/Application Support/Sublime Text 3/Packages/User/c.sublime-completions.sublime-snippet",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/sd_deploy.sh",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/goose64.out",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/player.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/vec2d.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/rebuild_models.sh",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/animation.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/character_anim.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gooseanimtypes.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/wavefront64/wavefront64.lua",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/export_animation.py",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/ART.md",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/characteranimtypes.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/character.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/collision.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/vec2d.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/vec3d.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/game.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/player.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/player.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/export_positions.py",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/animation.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gl/objloader.hpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gl/objloader.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/imgui/examples/imgui_impl_glut.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/imgui/examples/example_glut_opengl2/main.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/imgui/imgui_internal.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/imgui/imgui.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gameobject.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/imgui/imgui_demo.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/imgui/examples/example_glut_opengl2/Makefile",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/models/Person.blend",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/models/Person.blend1",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/characterrig.obj",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/glbuild.sh",
		"/Users/jfriend/code/N64-SoundTester/README.md",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/README.md",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/input.c",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/goose_anim.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gooserig.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/build_and_run.sh",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/graphic.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/n64compat.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/gameutils.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/item.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/input.h",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/item.cpp",
		"/Users/jfriend/.wine/drive_c/nintendo/n64kit/nusys/sample/nu1goose64/mathutils.h"
	],
	"find":
	{
		"height": 37.0
	},
	"find_in_files":
	{
		"height": 121.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"DEBUG_ANIMATION_MORE",
			"worldCoordsToScreen",
			"drawStringAtPointLocal",
			"drawStringAtPointLocalOrWorld",
			"origin",
			"drawStringA",
			"drawStringAtPoint",
			"lastModelView",
			"lastProjection",
			"lastModelView",
			"worldCoordsToScreen",
			"lastProjection",
			"lastModelView",
			"GLdouble*",
			"worldCoordsToScreen",
			"drawStringAtPoint",
			"lastModelView",
			"animFrameGlobalPos",
			"drawStringAtPoint",
			"animFrameGlobalPos",
			"DEBUG_ANIMATION_MORE",
			"DEBUG_OBJECTS",
			"drawStringAtPoint",
			"drawString",
			"drawStringAtPoint",
			"DEBUG_ANIMATION_MORE",
			"getMeshNameForModelMeshPart",
			"GooseMeshTypeStrings",
			"USE_FLAT_SHADING",
			"USE_LIGHTING_STATIC_ONLY",
			"Renderer_isCloser",
			"Renderer_isCloserBySeparatingPlane",
			"DRIVE_C",
			"/Users/jfriend/.wine/drive_c",
			"{",
			"${",
			"=\"",
			"CODEOBJECTS",
			" = ",
			"CODESEGMENT",
			"Renderer_isCloserBySeparatingPlane",
			"Renderer_sortWorldComparatorFn",
			"distance",
			"Renderer_gameobjectSortDist",
			"Renderer_sortWorldComparatorFn",
			"Renderer_calcIntersecting",
			"intersectingObjects",
			"DEBUG_ZBUFFER_INTERSECTING",
			"intersectingObjects",
			"gfxClearCfb",
			"Renderer_sortVisibleObjects",
			"objectsIntersecting",
			"drawGameObject",
			"intersectingObjects",
			"drawGameObject",
			"ZBugff",
			"Renderer_sortWorldComparatorFn",
			"Renderer_sortVisibleObjects",
			"(b)",
			"(a)",
			"aabbB",
			"aabbA",
			"aReallyClosestPoint",
			"debugPlane",
			"debugPlaneNormal",
			"body->position",
			"drawPhysBall",
			"drawTriNormal",
			"closestPoint",
			"sortWorldComparatorFn_viewPos",
			"Renderer_sortWorldComparatorFn",
			"Renderer_getSeparatingPlane",
			"Renderer_closestPointOnAABB",
			"result",
			"Plane_pointClosestPoint",
			"DEBUG_PAINTERS_ALGORITHM",
			"->n",
			"->d",
			"self->d",
			"debugPlane",
			"drawTriNormal",
			"up",
			"planeToViewDist",
			"planeToADist",
			"plane",
			"DEBUG_PAINTERS_ALGORITHM",
			"debugPlane",
			"drawPlane",
			"0.5f",
			"drawLine",
			"drawLin",
			"plane->point.",
			"+ plane->point.",
			"third",
			"upScaled-",
			"->",
			"up",
			"third-",
			"drawPlane",
			"up",
			"up.",
			"glTranslatef",
			"plane.",
			".",
			"hitPos",
			"drawMarker",
			"drawPlane",
			"Plane_set3Points",
			"draw",
			"Frustum_drawPlanes",
			"Renderer_getSeparatingPlane",
			"aCenter",
			"Renderer_getSeparatingPlane",
			"separatingPlane.point",
			"planeToADist",
			"DEBUG_PAINTERS_ALGORITHM",
			"aClosestPoint",
			"DEBUG_PAINTERS_ALGORITHM",
			"separatingPlane",
			"DEBUG_PAINTERS_ALGORITHM",
			"separatingPlane",
			"planeToViewDist",
			"planeToADist",
			"DEBUG_PAINTERS_ALGORITHM",
			"Renderer_getSeparatingPlane",
			"bReallyClosestPoint",
			"aReallyClosestPoint",
			"bReallyClosestPoint"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"drawMotionVectorLine"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 6,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "glgoose.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 78195,
						"regions":
						{
						},
						"selection":
						[
							[
								1178,
								1178
							]
						],
						"settings":
						{
							"SL.13.region_keys":
							[
							],
							"SL.26.region_keys":
							[
								"SL.clang++.Highlights.|2f292c7d47b35606801b683a210ace79f2ab8f7462572a95b5080c08d3345b1f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d0904cd397c3c828e6f1dac0d46f3edf14e247e353a3535e81995e5ba712a5eb|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|abae236481edb5a10bfdbab67f9ac60c8d26daaca24d4946f841d15b6b63e601|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b030bed61dbea5eab8b15cfb77b7de7fd0d8436c51295190f03f6433b821a6bf|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|46229bd7736e95f054d113e50d9e582ec55c7a3595fde13ba6ceae9a93a24870|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|03bac9d8ae9676cc58dd7ef5f26be0b9ea52dfa898b7a8973c4895a759ff189f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|68ecea22425152dc5e37aa24bdf47a4b61f95749185ab5d4613f013b37760ad3|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|f4549553d5849a4c439fa86f874b705562f50cb0c6e32d76fed43271e861321b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|4fac6f72204e1cf88c44f9c71f18a010b8c0095d2580567828b8ceda8a7ab5de|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|571e4bffdfcdcb98dcda485e7b37df2ecaed42b8294afe5e7992a3d86a7ed322|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|42e4db1e090fe665867dee6f2b8bdf6773de56b847a1af77eaee0e6b89b785f9|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|5b3215016892e75d35b58a36b47513b6b78723df197d5d590a8d42e2551a76fb|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.clang++.Highlights.|3b015036a67863263b2599b1f886ba736f57b1008b897621a0f51a55742a5a9c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d411b1232d864dfb930cd9cc996d3d8189a61d6ed583714a2a4a3ed88c7f4322|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|5315f9afa51fc606bc83bbec13b373d08db828f633f380acd5f4cc5f4e072b42|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|1415af9f817c26479594297631c60433e49842c33a85d831642d8c9e8f6afacc|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3978983d903f7f0eff4ace2fd8debb203e514892cb2182415e263e6e229e166f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|55f64844a78b6a2caebb169b7f74b6af97c023aaa7c74f02cd628aeb5550cc46|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|ec6908166f681dcf1d56bb590e1f319da26a36dfdeda1a47721cdc0456b85a64|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|73db5372ef12011cea290dc719099a232f2bf8683c302c85deacb4ce6d86ff16|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d47c319713126183eba080508641b55e25583372df57a7698dc0a8d7e97f942d|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|8ff3e3d8625ebb35b1c60fefda5feec9b7b3cb6f4c2d1a90287c02fd85f2e362|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|9b7ff1cb68b0c18151c4c0054fd88e8e822230adba882cf0ded61bce184be244|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|cb7394bd25485b223c8927019a16eef9525a7ca88b2b5501c769ae9345f758e8|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|9a32833e6c2a32acbd1e45c8cbce3ded8f8b4e075aada17d22246a7d7442c325|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|6392a4ddd7589a2eba4bceefda032fee16c116bf3bf6d8089690b930aa56f00f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|a585eb21164cfde40d1d1fa63c4b1f8d101f2187ed6e9747981bd33c2f758c01|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|82e802b80a4b4881117bbfe0e5596b17817fe6816b9cca9e4e1c1835da862933|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|ca15d138f0740c91af216d79753b657096332f346be6941f65762d840e54954e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|980d8a312d0a7a8a98a16fd8e7d18669c1e6b481dd35046dade0d11b74093c43|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|a84013a7dfa7232a4097c308c11e71daeb5b062c01cc96cc44b923ca6dc1ad86|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|fb5eace2c8fac7ece88af7376e79a8b721cd3c7ad2bff5798d5c682c7e330218|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|c521d8c2936705ddc0a7fa22012becbcb2f8ccd8ee8f78e1790402459df92489|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|17a47a49e94a128db18e3556de04e251b93d56f72bb4ef4b6a4dd4b3ee9864f9|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|709f4c5ed6c98ac70c0856e83929419256a49c4d719b7e7012a06f47c517e8f7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|c8301977d754f4c230d27b496687b7dd20e85b1e8d8f7168ad2c5b290e2b2d61|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3a0ed49fca6fc380cabeb952d1fe207c90cbfbe634f42c26f2882bd2892bda4e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|12609b91505dc00b16cb6cbccbbca628f5d3845c95cf6c64a208726e793ab2c0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|dc321c8afb627853e46d6263f9b818e7aef08371ebdbca7c8af545f57f98823d|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|42c64973443673b874ba12bca33ba149448480814c614de59aaa69d8b4591fa9|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|e11a4e6886f8f25a1c0183ae166bda2dc8767f20bd37224747082efd8136bc0d|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|945d81d6c8eaa0d5991e6e2fe3911d032c5acd7c2a56fef76d7b7e97cfe9172c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|bc20e47ae28d6daa79ba2f9ffe791523d967f2eb51af0364fe5a097fb0ce145a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|903771c6796ee109a1e2cc63623d3ab79a13370e5361ae8a34ed33c561a00088|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|6ba2948917a38937349d64cb60ff210ba2ad6869d90d48771359e14ec15dc5ed|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|9bb3ae26888505fcedbd8c91be3fee5a40185e9622587eca6eb4263db7f3497b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|4370d6138bcf687a2b8b1a57dea4d10e83eb5dad880372359365d8822807c9bd|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|ab33f124047ff8d26695eff59755a8c7d31f3aec790e41c0e48e6737a4f7bcf1|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|bb32b9c508b150c5edee0f842590c6dbbed05df89658bb0be137bc1f482c4382|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|692987a94be47d8c243a788324dd8304b278c21572aa0291e05f3c1d79da508f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|86299015167e49a9cddcaece6fa6428539c66000da6221a1f99541c4404a0265|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|ba572c50deed532e3dde85ed24a4808dbf8f379bdeda38c379c6184b96bd2d6c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Gutter.|region.yellowish markup.warning.sublime_linter|dot"
							],
							"SL.61.region_keys":
							[
								"SL.clang++.Highlights.|bc20e47ae28d6daa79ba2f9ffe791523d967f2eb51af0364fe5a097fb0ce145a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|55f64844a78b6a2caebb169b7f74b6af97c023aaa7c74f02cd628aeb5550cc46|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|1415af9f817c26479594297631c60433e49842c33a85d831642d8c9e8f6afacc|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|cb7394bd25485b223c8927019a16eef9525a7ca88b2b5501c769ae9345f758e8|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|9a32833e6c2a32acbd1e45c8cbce3ded8f8b4e075aada17d22246a7d7442c325|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|12609b91505dc00b16cb6cbccbbca628f5d3845c95cf6c64a208726e793ab2c0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b030bed61dbea5eab8b15cfb77b7de7fd0d8436c51295190f03f6433b821a6bf|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|42c64973443673b874ba12bca33ba149448480814c614de59aaa69d8b4591fa9|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|c521d8c2936705ddc0a7fa22012becbcb2f8ccd8ee8f78e1790402459df92489|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d411b1232d864dfb930cd9cc996d3d8189a61d6ed583714a2a4a3ed88c7f4322|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|945d81d6c8eaa0d5991e6e2fe3911d032c5acd7c2a56fef76d7b7e97cfe9172c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|692987a94be47d8c243a788324dd8304b278c21572aa0291e05f3c1d79da508f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3a0ed49fca6fc380cabeb952d1fe207c90cbfbe634f42c26f2882bd2892bda4e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|ba572c50deed532e3dde85ed24a4808dbf8f379bdeda38c379c6184b96bd2d6c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|9bb3ae26888505fcedbd8c91be3fee5a40185e9622587eca6eb4263db7f3497b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|571e4bffdfcdcb98dcda485e7b37df2ecaed42b8294afe5e7992a3d86a7ed322|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|e11a4e6886f8f25a1c0183ae166bda2dc8767f20bd37224747082efd8136bc0d|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3978983d903f7f0eff4ace2fd8debb203e514892cb2182415e263e6e229e166f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|5b3215016892e75d35b58a36b47513b6b78723df197d5d590a8d42e2551a76fb|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|6392a4ddd7589a2eba4bceefda032fee16c116bf3bf6d8089690b930aa56f00f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Gutter.|region.yellowish markup.warning.sublime_linter|dot",
								"SL.clang++.Highlights.|dc321c8afb627853e46d6263f9b818e7aef08371ebdbca7c8af545f57f98823d|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|68ecea22425152dc5e37aa24bdf47a4b61f95749185ab5d4613f013b37760ad3|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|9b7ff1cb68b0c18151c4c0054fd88e8e822230adba882cf0ded61bce184be244|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|709f4c5ed6c98ac70c0856e83929419256a49c4d719b7e7012a06f47c517e8f7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|bb32b9c508b150c5edee0f842590c6dbbed05df89658bb0be137bc1f482c4382|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|86299015167e49a9cddcaece6fa6428539c66000da6221a1f99541c4404a0265|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|8ff3e3d8625ebb35b1c60fefda5feec9b7b3cb6f4c2d1a90287c02fd85f2e362|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|4370d6138bcf687a2b8b1a57dea4d10e83eb5dad880372359365d8822807c9bd|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|c8301977d754f4c230d27b496687b7dd20e85b1e8d8f7168ad2c5b290e2b2d61|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|ca15d138f0740c91af216d79753b657096332f346be6941f65762d840e54954e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|fb5eace2c8fac7ece88af7376e79a8b721cd3c7ad2bff5798d5c682c7e330218|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|82e802b80a4b4881117bbfe0e5596b17817fe6816b9cca9e4e1c1835da862933|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|a84013a7dfa7232a4097c308c11e71daeb5b062c01cc96cc44b923ca6dc1ad86|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d0904cd397c3c828e6f1dac0d46f3edf14e247e353a3535e81995e5ba712a5eb|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|2f292c7d47b35606801b683a210ace79f2ab8f7462572a95b5080c08d3345b1f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|4fac6f72204e1cf88c44f9c71f18a010b8c0095d2580567828b8ceda8a7ab5de|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3b015036a67863263b2599b1f886ba736f57b1008b897621a0f51a55742a5a9c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|a585eb21164cfde40d1d1fa63c4b1f8d101f2187ed6e9747981bd33c2f758c01|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|46229bd7736e95f054d113e50d9e582ec55c7a3595fde13ba6ceae9a93a24870|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|f4549553d5849a4c439fa86f874b705562f50cb0c6e32d76fed43271e861321b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|980d8a312d0a7a8a98a16fd8e7d18669c1e6b481dd35046dade0d11b74093c43|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d47c319713126183eba080508641b55e25583372df57a7698dc0a8d7e97f942d|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|73db5372ef12011cea290dc719099a232f2bf8683c302c85deacb4ce6d86ff16|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.clang++.Highlights.|ec6908166f681dcf1d56bb590e1f319da26a36dfdeda1a47721cdc0456b85a64|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|03bac9d8ae9676cc58dd7ef5f26be0b9ea52dfa898b7a8973c4895a759ff189f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|abae236481edb5a10bfdbab67f9ac60c8d26daaca24d4946f841d15b6b63e601|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|6ba2948917a38937349d64cb60ff210ba2ad6869d90d48771359e14ec15dc5ed|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|ab33f124047ff8d26695eff59755a8c7d31f3aec790e41c0e48e6737a4f7bcf1|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|17a47a49e94a128db18e3556de04e251b93d56f72bb4ef4b6a4dd4b3ee9864f9|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|42e4db1e090fe665867dee6f2b8bdf6773de56b847a1af77eaee0e6b89b785f9|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|5315f9afa51fc606bc83bbec13b373d08db828f633f380acd5f4cc5f4e072b42|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|903771c6796ee109a1e2cc63623d3ab79a13370e5361ae8a34ed33c561a00088|region.yellowish markup.warning.sublime_linter|32"
							],
							"SL.64.region_keys":
							[
								"SL.clang++.Highlights.|9afe8d0d1015182b73476750de40271851beb9e38fa62b03155ec10d2afc7ec1|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b14060a17c3884bf61ab406917e183fd715ada6ba700e23d547e9183ea499cc0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|0ed4c4ef6a62fdc774bd2a75ff0f6c5cc0bfa40b8df2461842645b77355f8f6b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3f32221d4e7224d77caf6ec039800c5ee348b5e78bdfe4f2c158cdeeb655022a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|0f837f3654295de60718d97f714b9d3a38a2fb3d775999dca39df07c69d3e04e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|6230efa292078ff003ebcce82590360ab59806f17b41f0bb6d3d382bd7e5a8de|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|0bf04bf36a5d9c9692bac79e491d0a39312de2598e22fb902d0f0c37e31a7437|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|28a57c63fc0bef7f5078bec38f9089a4bbbcde5d8b11a6e55673f534cc8e68fb|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Gutter.|region.yellowish markup.warning.sublime_linter|dot",
								"SL.clang++.Highlights.|55703bd17edaa2ffdf47a77a902c20f7d65fd97b4b45bd2e6425eac1d348d38e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|8e1edeea3dfc3a8f3314ee0b4db4609779593586070b602e19db8e48c34a9ce7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|fe55bb9b01c632026eefc9c8e62d71da30f3843efa158bacf8be2ee6d4a60a45|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|f1e620441b2c28bf2273af0d4f53a08370c5b980579757d0d17cf7b824940760|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|825d9b9fce127f1a1592ba76327f89b8d4525bd206da92b95eae951a5d5aa9b5|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|624ae5b20dcce80286f35be5200b00b227a16cbd56a87d4a661f15deb15a654e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|c47e422371712d260fa217068c6a80291898d749c49842e890c039240d96159c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|cc9d2a192b9c773a5de93851d0465a7aea8f94a53f7c1ad161ad16626769e526|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|97cda486ae7bf4ac1bb0c31edcd86f0d6f61e6d865838b014ce92369723f127a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|730d781d6d81f4f0dfe94e19ade064efd2f9694a5d6e4ac8bbfd5faeb027f492|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|1d95e5add40c6612205cce43074765eaed78d2e0ede6861733da81e87e8eef94|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b9a923207b1a97a7a5c45042be30fb7a58d6660c52730d8c7ba07f5191c5beb7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|888f3a71ec0abae12a1248a1f6355b2f8b8538c6b5b10cf38f389c66f8633595|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d226dd4f1d8813da4963a904b5d926435fbf38101579c4fa87826d541651364f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|626637c7f7bb404de0dcfb6416352ec05926731fddbd480ca536ea4f8cad0941|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7ca42883c23f0cb902fc39b0f7778bd0ff85327d41e7e4890e8cee5693f1a51e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|43749511fc68bbc35927b6893f7c1b5f54c9a01671af2a42abdc7737e365ac3b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|bf35054c9ded169f1f4a8ec75c15bdc87ca432b5565d4387ae772ba72da1c9dc|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|34f304c9007513926dbe372fa4a58feba51fd919771ca234792db8c3f197781c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|20a96ce8aa7347609eb8afea984e05871d325a44787143cc0db286649521470b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|db8afadf22c4271f32a332b098684fb14cff641257ce6201a7c6394673d2dca3|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3bf37ff5e9ff497930f9d9b66bd7d494f124c1a863256dc0408fe5e7b8ec8628|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|30a5f46baf418d3d1dc05b094936b37bfdbf1364906adfb039a2bffe7c70ab50|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|07c210e716c5d1f5e530deedeb1c5d1c685204be180be27a910d328812a47abd|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|2d33fd52f99d706f9a5f6b2d1902262d2db445a568fad40de8d9f51c1a5bb9a1|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|38ecd9d9f854f06177577a08dd3cb10989b7bfd09850dce06601b15947f87056|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|e5bdafbc2640045d01b2d1e89a3829da56c025bf2d26a2c5c0b10e78109c9e59|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d2db2994f62fe05707b4a9b006af4fb7b4d5414cb8574b3ff732e7d70fe67cbc|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|0f45d51b5ca6f8950ecea03dd3fb37eb816519e1608c8169856401675374f1a0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d88b87db95404b5a824265b9cce53931ccf17a16ffa47117b13b6702c9398b97|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7ad7d80c574ab830a140dfa9b8b05db08d33a88ccf5672fd14cc4bec26cf7f0f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|f23e88da1b4bb5d5a2a5447342df97f0bb3a61f2f1d6537fe2ba444d2c8fd9fb|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|83a4e9a1f8ec75d2d4215396c041f091750b994cd0f649bee1a6ad26064de1db|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|04f56be9ce6e0445e9f5e9173277c6b0f96df851bc168abdb0602b104d50e0b0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|db1f5fb73000389769de2477314872848699b99b1a11b4b933e37d48cda84352|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b1b160317b4486c95183923e998fbfb2d44775bc7c1e1c503cfa4480bf3a1cd0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|66f77190a4a1bb62d8114f844ca6df1e992b8f2186ab9911f6df205136d2ebda|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|62d5c9a5fcc51e1e6cee75f00ce81b8a061382c4f6feb2a46ab731ea4e0183c7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7daf69b93eec62b8a92aeba3c41aae0d45f9a4fa4e10ac3ffdda6b0fa09e5a6a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|4b603cf2c20ac48329878f3650d54f32fb6b37d62701e71c1d78480ae9fa0aa2|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|20fd8d9a2c3d741c9cb520cc2149beb90e60435373ec742311565234fe29c822|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.clang++.Highlights.|d1d01cd156e4c2d968395808057b78bc038881ce4dada88a39e9c85c1221da17|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7b0ee449bf8bddfcaa82d6433c0eae9854f27b0f31e46400a6e5d367a46968ef|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|caf04f8727178865783dca3577355452ab04f1661c7a9c6f632e2e9d18d59550|region.yellowish markup.warning.sublime_linter|32"
							],
							"SL.983.region_keys":
							[
								"SL.clang++.Highlights.|20fd8d9a2c3d741c9cb520cc2149beb90e60435373ec742311565234fe29c822|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b1b160317b4486c95183923e998fbfb2d44775bc7c1e1c503cfa4480bf3a1cd0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|db8afadf22c4271f32a332b098684fb14cff641257ce6201a7c6394673d2dca3|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|cc9d2a192b9c773a5de93851d0465a7aea8f94a53f7c1ad161ad16626769e526|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|e5bdafbc2640045d01b2d1e89a3829da56c025bf2d26a2c5c0b10e78109c9e59|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b9a923207b1a97a7a5c45042be30fb7a58d6660c52730d8c7ba07f5191c5beb7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|66f77190a4a1bb62d8114f844ca6df1e992b8f2186ab9911f6df205136d2ebda|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|b14060a17c3884bf61ab406917e183fd715ada6ba700e23d547e9183ea499cc0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7daf69b93eec62b8a92aeba3c41aae0d45f9a4fa4e10ac3ffdda6b0fa09e5a6a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|8e1edeea3dfc3a8f3314ee0b4db4609779593586070b602e19db8e48c34a9ce7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|28a57c63fc0bef7f5078bec38f9089a4bbbcde5d8b11a6e55673f534cc8e68fb|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3bf37ff5e9ff497930f9d9b66bd7d494f124c1a863256dc0408fe5e7b8ec8628|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|0bf04bf36a5d9c9692bac79e491d0a39312de2598e22fb902d0f0c37e31a7437|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7ad7d80c574ab830a140dfa9b8b05db08d33a88ccf5672fd14cc4bec26cf7f0f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d226dd4f1d8813da4963a904b5d926435fbf38101579c4fa87826d541651364f|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|30a5f46baf418d3d1dc05b094936b37bfdbf1364906adfb039a2bffe7c70ab50|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|20a96ce8aa7347609eb8afea984e05871d325a44787143cc0db286649521470b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|07c210e716c5d1f5e530deedeb1c5d1c685204be180be27a910d328812a47abd|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|97cda486ae7bf4ac1bb0c31edcd86f0d6f61e6d865838b014ce92369723f127a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d1d01cd156e4c2d968395808057b78bc038881ce4dada88a39e9c85c1221da17|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d88b87db95404b5a824265b9cce53931ccf17a16ffa47117b13b6702c9398b97|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|f23e88da1b4bb5d5a2a5447342df97f0bb3a61f2f1d6537fe2ba444d2c8fd9fb|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|bf35054c9ded169f1f4a8ec75c15bdc87ca432b5565d4387ae772ba72da1c9dc|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|38ecd9d9f854f06177577a08dd3cb10989b7bfd09850dce06601b15947f87056|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|04f56be9ce6e0445e9f5e9173277c6b0f96df851bc168abdb0602b104d50e0b0|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.clang++.Highlights.|624ae5b20dcce80286f35be5200b00b227a16cbd56a87d4a661f15deb15a654e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|db1f5fb73000389769de2477314872848699b99b1a11b4b933e37d48cda84352|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|c47e422371712d260fa217068c6a80291898d749c49842e890c039240d96159c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|9afe8d0d1015182b73476750de40271851beb9e38fa62b03155ec10d2afc7ec1|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|3f32221d4e7224d77caf6ec039800c5ee348b5e78bdfe4f2c158cdeeb655022a|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Gutter.|region.yellowish markup.warning.sublime_linter|dot",
								"SL.clang++.Highlights.|0ed4c4ef6a62fdc774bd2a75ff0f6c5cc0bfa40b8df2461842645b77355f8f6b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7b0ee449bf8bddfcaa82d6433c0eae9854f27b0f31e46400a6e5d367a46968ef|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|6230efa292078ff003ebcce82590360ab59806f17b41f0bb6d3d382bd7e5a8de|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|caf04f8727178865783dca3577355452ab04f1661c7a9c6f632e2e9d18d59550|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|fe55bb9b01c632026eefc9c8e62d71da30f3843efa158bacf8be2ee6d4a60a45|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|0f837f3654295de60718d97f714b9d3a38a2fb3d775999dca39df07c69d3e04e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|888f3a71ec0abae12a1248a1f6355b2f8b8538c6b5b10cf38f389c66f8633595|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|1d95e5add40c6612205cce43074765eaed78d2e0ede6861733da81e87e8eef94|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|825d9b9fce127f1a1592ba76327f89b8d4525bd206da92b95eae951a5d5aa9b5|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|0f45d51b5ca6f8950ecea03dd3fb37eb816519e1608c8169856401675374f1a0|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|626637c7f7bb404de0dcfb6416352ec05926731fddbd480ca536ea4f8cad0941|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|7ca42883c23f0cb902fc39b0f7778bd0ff85327d41e7e4890e8cee5693f1a51e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|43749511fc68bbc35927b6893f7c1b5f54c9a01671af2a42abdc7737e365ac3b|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|34f304c9007513926dbe372fa4a58feba51fd919771ca234792db8c3f197781c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|2d33fd52f99d706f9a5f6b2d1902262d2db445a568fad40de8d9f51c1a5bb9a1|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|83a4e9a1f8ec75d2d4215396c041f091750b994cd0f649bee1a6ad26064de1db|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|4b603cf2c20ac48329878f3650d54f32fb6b37d62701e71c1d78480ae9fa0aa2|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|62d5c9a5fcc51e1e6cee75f00ce81b8a061382c4f6feb2a46ab731ea4e0183c7|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|55703bd17edaa2ffdf47a77a902c20f7d65fd97b4b45bd2e6425eac1d348d38e|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|730d781d6d81f4f0dfe94e19ade064efd2f9694a5d6e4ac8bbfd5faeb027f492|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|d2db2994f62fe05707b4a9b006af4fb7b4d5414cb8574b3ff732e7d70fe67cbc|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang++.Highlights.|f1e620441b2c28bf2273af0d4f53a08370c5b980579757d0d17cf7b824940760|region.yellowish markup.warning.sublime_linter|32"
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content"
							],
							"force_encoding": "GBK",
							"in_converting": true,
							"is_init_dirty_state": false,
							"origin_content": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#ifdef __APPLE__\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\n#include <OpenGL/gl.h>\n#include <OpenGL/glu.h>\n#include <glm/glm.hpp>\n\n// Dear Imgui\n#include \"imgui/imgui.h\"\n// imgui.h needs to be before these\n#include \"imgui/examples/imgui_impl_glut.h\"\n#include \"imgui/examples/imgui_impl_opengl2.h\"\n\n#include \"animation.h\"\n#include \"character.h\"\n#include \"collision.h\"\n#include \"constants.h\"\n#include \"frustum.h\"\n#include \"game.h\"\n#include \"gameobject.h\"\n#include \"gameutils.h\"\n#include \"gl/objloader.hpp\"\n#include \"gl/texture.hpp\"\n#include \"input.h\"\n#include \"nodegraph/nodegraph.hpp\"\n#include \"pathfinding.h\"\n#include \"player.h\"\n#include \"renderer.h\"\n#include \"vec3d.h\"\n\n#include \"garden_map.h\"\n#include \"garden_map_collision.h\"\n#include \"garden_map_graph.h\"\n\n#include \"character_anim.h\"\n#include \"goose_anim.h\"\n\n#define FREEVIEW_SPEED 0.2f\n\n#define DEBUG_LOG_RENDER 0\n#define DEBUG_TEXT_BASIC 0\n#define DEBUG_OBJECTS 0\n#define DEBUG_RAYCASTING 0\n#define DEBUG_MODELS 0\n\n#define DEBUG_ANIMATION 0\n#define DEBUG_ANIMATION_MORE 0\n#define DEBUG_ATTACHMENT 0\n\n#define DEBUG_PHYSICS 0\n\n#define DEBUG_COLLISION_MESH 0\n#define DEBUG_COLLISION_MESH_MORE 0\n#define DEBUG_COLLISION_SPATIAL_HASH 0\n#define DEBUG_COLLISION_SPATIAL_HASH_RAYCAST 0\n#define DEBUG_COLLISION_SPATIAL_HASH_TRIS 0\n#define DEBUG_COLLISION_MESH_AABB 0\n\n#define DEBUG_AABB 0\n#define DEBUG_FRUSTUM 0\n#define DEBUG_ZBUFFER_INTERSECTING 1\n#define DEBUG_PAINTERS_ALGORITHM_SEPARATING_PLANE 1\n\n#define DEBUG_PATHFINDING_GRAPH 0\n#define DEBUG_PATHFINDING 0\n#define DEBUG_PATHFINDING_AUTO 0\n\n#define DEBUG_PROFILING 0\n\n#define USE_SPRITES 0\n#define USE_LIGHTING 1\n#define USE_LIGHTING_STATIC_ONLY 1\n#define USE_FLAT_SHADING 1\n#define USE_ANIM_FRAME_LERP 1\n#define ENABLE_NODEGRAPH_EDITOR 0\n\nint glgooseFrame = 0;\nint updateSkipRate = 1;\n\n// actual vector representing the freeview camera's direction\nfloat cameraLX = 0.0f, cameraLZ = -1.0f;\n// XZ position of the freeview camera\nVec3d freeViewPos = {0.0f, 50.0f, 0.0f};\n// freeview camera angle\nfloat cameraAngle = 180.0f;\nbool enableControlsInFreeView = false;\nint frustumPlaneToTest = -1;\n\nstatic Frustum frustum;\nstatic float fovy = DEFAULT_FOVY;\nstatic float aspect = 800 / 600;\nstatic Vec3d upVector = {0.0f, 1.0f, 0.0f};\nstatic float nearPlane = DEFAULT_NEARPLANE;\nstatic float farPlane = DEFAULT_FARPLANE;\n\nbool keysDown[127];\nInput input;\nGameObject* selectedObject = NULL;\n\nPhysWorldData physWorldData = {garden_map_collision_collision_mesh,\n                               GARDEN_MAP_COLLISION_LENGTH,\n                               &garden_map_collision_collision_mesh_hash,\n                               /*gravity*/ -9.8 * N64_SCALE_FACTOR,\n                               /*viscosity*/ 0.05,\n                               /*waterHeight*/ WATER_HEIGHT};\n\n// crap for gluProject/gluUnProject\nGLdouble lastModelView[16];\nGLdouble lastProjection[16];\nGLint lastViewport[4];\n\n// profiling\nfloat profAvgCharacters = 0;\nfloat profAvgPhysics = 0;\nfloat profAvgDraw = 0;\nfloat profAvgPath = 0;\n\nObjModel models[MAX_MODEL_TYPE];\n\nstd::vector<GLuint> sprites[MAX_SPRITE_TYPE];\n\nchar* GooseMeshTypeStrings[] = {\n    \"goosebody_goosebodymesh\",      //\n    \"goosehead_gooseheadmesh\",      //\n    \"gooseleg_l_gooseleg_lmesh\",    //\n    \"goosefoot_l_goosefoot_lmesh\",  //\n    \"gooseleg_r_gooseleg_rmesh\",    //\n    \"goosefoot_r_goosefoot_rmesh\",  //\n    \"gooseneck_gooseneckmesh\",      //\n    \"MAX_GOOSE_MESH_TYPE\",          //\n};\n\nchar* CharacterMeshTypeStrings[] = {\n    \"gkbicep.l_gkbicep_lrmesh\",      // characterbicep_l_characterbicep_lmesh\n    \"gkbicep.r_gkbicep_rmesh\",       // characterbicep_r_characterbicep_rmesh\n    \"gkfoot.l_gkfoot_lrmesh\",        // characterfoot_l_characterfoot_lmesh\n    \"gkfoot.r_gkfoot_rmesh\",         // characterfoot_r_characterfoot_rmesh\n    \"gkforearm.l_gkforearm_lrmesh\",  // characterforearm_l_characterforearm_lmesh\n    \"gkforearm.r_gkforearm_rmesh\",  // characterforearm_r_characterforearm_rmesh\n    \"gkhead_gkheadmesh\",            // characterhead_characterheadmesh\n    \"gkshin.l_gkshin_lmesh\",        // charactershin_l_charactershin_lmesh\n    \"gkshin.r_gkshin_rmesh\",        // charactershin_r_charactershin_rmesh\n    \"gktorso_gktorsomesh\",          // charactertorso_charactertorsomesh\n    \"gkthigh.l_gkthigh_lmesh\",      // characterthigh_l_characterthigh_lmesh\n    \"gkthigh.r_gkthigh_rmesh\",      // characterthigh_r_characterthigh_rmesh\n};\n\nstd::vector<glm::vec3> spriteVertices = {\n    {0.0f, 1.0f, 0.0f},  //\n    {1.0f, 0.0f, 0.0f},  //\n    {0.0f, 0.0f, 0.0f},  //\n    {0.0f, 1.0f, 0.0f},  //\n    {1.0f, 1.0f, 0.0f},  //\n    {1.0f, 0.0f, 0.0f},  //\n};\nstd::vector<glm::vec2> spriteUVs = {\n    {0.0f, 1.0f},  //\n    {1.0f, 0.0f},  //\n    {0.0f, 0.0f},  //\n    {0.0f, 1.0f},  //\n    {1.0f, 1.0f},  //\n    {1.0f, 0.0f},  //\n};\n\nint debugPathfindingFrom = 3;\nint debugPathfindingTo = 8;\nGraph* pathfindingGraph = &garden_map_graph;\nPathfindingState* pathfindingState = &garden_map_graph_pathfinding_state;\n\nstatic NodeGraph nodeGraph = NodeGraph();\nstatic int selectedNode = -1;\n\nAABB* localAABBs = garden_map_bounds;\nstatic int frustumCulled = 0;\n\nvoid loadModel(ModelType modelType, char* modelfile, char* texfile) {\n  // the map exporter scales the world up by this much, so we scale up the\n  // meshes to match\n  loadOBJ(modelfile, models[modelType], N64_SCALE_FACTOR);\n  models[modelType].texture = loadBMP_custom(texfile);\n}\n\nvoid loadSprite(SpriteType spriteType, std::vector<std::string> texfiles) {\n  std::for_each(\n      texfiles.begin(), texfiles.end(), [spriteType](std::string& texfile) {\n        sprites[spriteType].push_back(loadBMP_custom(texfile.c_str()));\n      });\n}\n\nvoid screenCoordsToWorld(Vec3d* screenPos, Vec3d* result) {\n  GLdouble res[3];\n\n  gluUnProject(/*winX*/ screenPos->x,\n               /*winY*/ screenPos->y,\n               /*winZ*/ screenPos->z, lastModelView, lastProjection,\n               lastViewport,\n               /*objX*/ &res[0],\n               /*objY*/ &res[1],\n               /*objZ*/ &res[2]);\n\n  Vec3d_init(result, res[0], res[1], res[2]);\n}\n\nbool worldCoordsToScreen(Vec3d* pos, Vec3d* result) {\n  GLdouble scr[3];\n\n  bool success =\n      gluProject(pos->x, pos->y, pos->z, lastModelView, lastProjection,\n                 lastViewport, &scr[0], &scr[1], &scr[2]);\n\n  int screenSizeX = lastViewport[2];\n  int screenSizeY = lastViewport[3];\n\n  if (success &&\n      // valid number range\n      (scr[0] >= 0 && scr[1] >= 0 && scr[2] >= 0) &&\n      (scr[0] <= FLT_MAX && scr[1] <= FLT_MAX && scr[2] <= FLT_MAX) &&\n      // inside 2d viewport extents\n      (scr[0] < screenSizeX && scr[1] < screenSizeY)) {\n    result->x = scr[0];\n    result->y = scr[1];\n    result->z = scr[2];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstd::string formatVec3d(Vec3d* self) {\n  char buffer[60];\n  sprintf(buffer, \"{x:%.3f, y:%.3f, z:%.3f}\", self->x, self->y, self->z);\n  return buffer;\n}\n\nstd::string formatEuler(EulerDegrees* self) {\n  char buffer[60];\n  sprintf(buffer, \"{x:%.3f, y:%.3f, z:%.3f}\", self->x, self->y, self->z);\n  return buffer;\n}\n\nvoid drawGUI() {\n  Game* game = Game_get();\n  GameObject* obj = selectedObject;\n  Character* selectedCharacter =\n      obj == Game_get()->characters->obj ? Game_get()->characters : NULL;\n  ImGuiInputTextFlags inputFlags =\n      ImGuiInputTextFlags_EnterReturnsTrue;  // only update on blur\n\n  ImGui::Begin(\"Objects\");  // Create a window\n  for (int i = 0; i < game->worldObjectsCount; i++) {\n    GameObject* listObj = game->worldObjects + i;\n    if (ImGui::Selectable(\n            (std::to_string(i) + \" \" + ModelTypeStrings[listObj->modelType])\n                .c_str(),\n            listObj == obj)) {\n      selectedObject = listObj;\n    }\n  }\n  ImGui::End();\n\n  ImGui::Begin(\"Object Inspector\");  // Create a window\n\n  // Display some text (you can use a format strings too)\n  ImGui::Text(\"Selected object: %d (%s)\", obj ? obj->id : -1,\n              obj ? ModelTypeStrings[obj->modelType] : \"none\");\n\n  if (obj) {\n    int spatialHashResults[100];\n    Vec3d objCenter;\n    Game_getObjCenter(obj, &objCenter);\n\n    if (ImGui::CollapsingHeader(\"Object\", ImGuiTreeNodeFlags_DefaultOpen)) {\n      ImGui::InputFloat3(\"Position\", (float*)&obj->position, \"%.3f\",\n                         inputFlags);\n      ImGui::InputFloat3(\"Rotation\", (float*)&obj->rotation, \"%.3f\",\n                         inputFlags);\n      ImGui::InputFloat3(\n          \"centroidOffset\",\n          (float*)&modelTypesProperties[obj->modelType].centroidOffset, \"%.3f\",\n          inputFlags);\n\n      ImGui::InputFloat(\"radius\",\n                        (float*)&modelTypesProperties[obj->modelType].radius,\n                        0.1, 1.0, \"%.3f\", inputFlags);\n      ImGui::InputInt(\"subtype\", (int*)&obj->subtype, 0, 1,\n                      ImGuiInputTextFlags_ReadOnly);\n\n      AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n\n      ImGui::InputFloat3(\"worldAABB.min\", (float*)&worldAABB.min, \"%.3f\",\n                         ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat3(\"worldAABB.max\", (float*)&worldAABB.max, \"%.3f\",\n                         ImGuiInputTextFlags_ReadOnly);\n    }\n    if (obj->physBody) {\n      if (ImGui::CollapsingHeader(\"Physics\", ImGuiTreeNodeFlags_DefaultOpen)) {\n        ImGui::InputInt(\"physBody\", (int*)&obj->physBody->id, 0, 1,\n                        ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"phys Velocity\",\n                           (float*)&obj->physBody->nonIntegralVelocity, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"phys Acceleration\",\n                           (float*)&obj->physBody->nonIntegralAcceleration,\n                           \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n\n        ImGui::InputFloat3(\"phys position\", (float*)&obj->physBody->position,\n                           \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"phys prevPosition\",\n                           (float*)&obj->physBody->prevPosition, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputInt(\"phys enabled\", (int*)&obj->physBody->enabled, 0, 1,\n                        ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputInt(\"phys controlled\", (int*)&obj->physBody->controlled, 0,\n                        1, ImGuiInputTextFlags_ReadOnly);\n      }\n    }\n    if (obj->animState) {\n      if (ImGui::CollapsingHeader(\"Animation\",\n                                  ImGuiTreeNodeFlags_DefaultOpen)) {\n        ImGui::InputInt(\"state\", (int*)&obj->animState->state, 0, 1,\n                        ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"progress\", (float*)&obj->animState->progress, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n      }\n    }\n    if (selectedCharacter) {\n      if (ImGui::CollapsingHeader(\"Character\",\n                                  ImGuiTreeNodeFlags_DefaultOpen)) {\n        Vec3d heading;\n        GameUtils_directionFromTopDownAngle(obj->rotation.y, &heading);\n        ImGui::InputFloat3(\"heading\", (float*)&heading, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat3(\"targetLocation\",\n                           (float*)&selectedCharacter->targetLocation, \"%.3f\",\n                           ImGuiInputTextFlags_ReadOnly);\n        ImGui::Text(\"state: %s\",\n                    CharacterStateStrings[selectedCharacter->state]);\n\n        ImGui::InputFloat(\"speedMultiplier\",\n                          (float*)&selectedCharacter->speedMultiplier, 0.1, 1.0,\n                          \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"heading speed scale\",\n                          (float*)&selectedCharacter->speedScaleForHeading, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\n            \"heading turn scale\",\n            (float*)&selectedCharacter->turningSpeedScaleForHeading, 0.1, 1.0,\n            \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"arrival speed scale\",\n                          (float*)&selectedCharacter->speedScaleForArrival, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputInt(\"pathProgress\", (int*)&selectedCharacter->pathProgress,\n                        0, 1, ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"pathSegmentProgress\",\n                          (float*)&selectedCharacter->pathSegmentProgress, 0.1,\n                          1.0, \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        if (selectedCharacter->pathfindingResult) {\n          ImGui::Text(\"path:\");\n          int i;\n          int* pathNodeID;\n\n          for (i = 0,\n              pathNodeID = selectedCharacter->pathfindingResult->result;  //\n               i < selectedCharacter->pathfindingResult->resultSize;      //\n               i++, pathNodeID++) {\n            ImGui::Text(\"%d: %d\", i, *pathNodeID);\n          }\n        }\n      }\n    }\n\n    if (ImGui::CollapsingHeader(\"Collision\")) {\n      ImGui::InputInt(\"testCollisionResult\", (int*)&testCollisionResult, 0, 1,\n                      inputFlags);\n\n      std::string collKeys;\n      if (testCollisionResults.size()) {\n        std::map<int, SphereTriangleCollision>::iterator collIter =\n            testCollisionResults.begin();\n\n        while (collIter != testCollisionResults.end()) {\n          collKeys += std::to_string(collIter->first) + \",\";\n\n          collIter++;\n        }\n      }\n      ImGui::Text(\"colliding tris=%s\", collKeys.c_str());\n\n      int spatialHashResultsCount = SpatialHash_getTriangles(\n          &objCenter, Game_getObjRadius(obj),\n          physWorldData.worldMeshSpatialHash, spatialHashResults,\n          /*maxResults*/ 100);\n\n      std::string bucketKeys;\n      int i;\n      for (i = 0; i < spatialHashResultsCount; i++) {\n        bucketKeys += std::to_string(spatialHashResults[i]) + \",\";\n      }\n\n      ImGui::Text(\"grid pos x=%f, y=%f\",\n                  SpatialHash_unitsToGridFloatForDimension(\n                      objCenter.x, physWorldData.worldMeshSpatialHash),\n                  SpatialHash_unitsToGridFloatForDimension(\n                      objCenter.z, physWorldData.worldMeshSpatialHash));\n\n      ImGui::Text(\"current bucket tris=%s\", bucketKeys.c_str());\n    }\n  }\n\n  if (ImGui::CollapsingHeader(\"Global\", ImGuiTreeNodeFlags_DefaultOpen)) {\n    ImGui::InputFloat(\"physWorldData.gravity\", (float*)&physWorldData.gravity,\n                      1.0, 10.0, \"%.3f\", inputFlags);\n\n    ImGui::InputInt(\"updateSkipRate\", (int*)&updateSkipRate, 1, 10, inputFlags);\n    updateSkipRate = MAX(updateSkipRate, 1);\n  }\n\n  if (ImGui::CollapsingHeader(\"Camera\",\n#if DEBUG_FRUSTUM\n                              ImGuiTreeNodeFlags_DefaultOpen\n#else\n                              0\n#endif\n                              )) {\n    ImGui::InputFloat3(\"viewPos\", (float*)&game->viewPos, \"%.3f\");\n    ImGui::InputFloat3(\"viewTarget\", (float*)&game->viewTarget, \"%.3f\");\n    ImGui::InputFloat3(\"freeViewPos\", (float*)&freeViewPos, \"%.3f\");\n    ImGui::Checkbox(\"enableControlsInFreeView\", &enableControlsInFreeView);\n    ImGui::Combo(\"plane to test\", &frustumPlaneToTest, FrustumPlanesStrings,\n                 NUM_FRUSTUM_PLANES);\n\n    if (obj) {\n      {\n        ImGui::Text(\"frustum test results for obj=%d\", obj->id);\n\n        AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n\n        ImGui::Text(\"boxInFrustum: %s\",\n                    FrustumTestResultStrings[Frustum_boxInFrustum(&frustum,\n                                                                  &worldAABB)]);\n        ImGui::Text(\"boxInFrustumNaive: %s\",\n                    FrustumTestResultStrings[Frustum_boxInFrustumNaive(\n                        &frustum, &worldAABB)]);\n        ImGui::Text(\"Per plane tests:\");\n        for (int i = 0; i < NUM_FRUSTUM_PLANES; ++i) {\n          ImGui::Text(\"%s: %s\", FrustumPlanesStrings[i],\n                      FrustumTestResultStrings[Frustum_boxFrustumPlaneTestPN(\n                          &frustum, &worldAABB, i)]);\n        }\n      }\n\n#if DEBUG_PAINTERS_ALGORITHM_SEPARATING_PLANE\n      if (obj) {\n        GameObject* a = game->player.goose;\n        GameObject* b = selectedObject;\n        RendererSortDistance sortDistA, sortDistB;\n        Plane separatingPlane;\n        Vec3d aCenter, bCenter, aClosestPoint, bClosestPoint,\n            aReallyClosestPoint, bReallyClosestPoint;\n        Game_getObjCenter(a, &aCenter);\n        Game_getObjCenter(b, &bCenter);\n        AABB aabbA = Renderer_getWorldAABB(localAABBs, a);\n        AABB aabbB = Renderer_getWorldAABB(localAABBs, b);\n        sortDistA = (RendererSortDistance){\n            /*obj*/ game->player.goose,\n            /*distance*/ 0,\n            /*worldAABB*/\n            Renderer_getWorldAABB(localAABBs, game->player.goose)};\n        sortDistB = (RendererSortDistance){\n            /*obj*/ selectedObject,\n            /*distance*/ 0,\n            /*worldAABB*/ Renderer_getWorldAABB(localAABBs, selectedObject)};\n        int aCloser = Renderer_isCloserBySeparatingPlane(&sortDistA, &sortDistB,\n                                                         &game->viewPos);\n\n        Renderer_closestPointOnAABB(&aabbA, &bCenter, &aClosestPoint);\n        Renderer_closestPointOnAABB(&aabbB, &aCenter, &bClosestPoint);\n\n        Renderer_closestPointOnAABB(&aabbA, &bClosestPoint,\n                                    &aReallyClosestPoint);\n        Renderer_closestPointOnAABB(&aabbB, &aClosestPoint,\n                                    &bReallyClosestPoint);\n\n        Renderer_getSeparatingPlane(&aReallyClosestPoint, &bReallyClosestPoint,\n                                    &separatingPlane);\n\n        float planeToADist = Plane_distance(&separatingPlane, &aCenter);\n        float planeToViewDist =\n            Plane_distance(&separatingPlane, &game->viewPos);\n\n        ImGui::InputFloat3(\"aCenter\", (float*)&aCenter, \"%.3f\");\n        ImGui::InputFloat3(\"separatingPlane.point\",\n                           (float*)&separatingPlane.point, \"%.3f\");\n        ImGui::InputFloat(\"planeToADist\", (float*)&planeToADist, 0.1, 1.0,\n                          \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::InputFloat(\"planeToViewDist\", (float*)&planeToViewDist, 0.1, 1.0,\n                          \"%.3f\", ImGuiInputTextFlags_ReadOnly);\n        ImGui::Text(aCloser == -1 ? \"goose is closer than selectedObject\"\n                                  : \"goose is NOT closer than selectedObject\");\n      }\n#endif\n    }\n\n    if (ImGui::CollapsingHeader(\"Camera++\")) {\n      ImGui::InputFloat3(\"ntl\", (float*)&frustum.ntl, \"%.3f\");\n      ImGui::InputFloat3(\"ntr\", (float*)&frustum.ntr, \"%.3f\");\n      ImGui::InputFloat3(\"nbl\", (float*)&frustum.nbl, \"%.3f\");\n      ImGui::InputFloat3(\"nbr\", (float*)&frustum.nbr, \"%.3f\");\n      ImGui::InputFloat3(\"ftl\", (float*)&frustum.ftl, \"%.3f\");\n      ImGui::InputFloat3(\"ftr\", (float*)&frustum.ftr, \"%.3f\");\n      ImGui::InputFloat3(\"fbl\", (float*)&frustum.fbl, \"%.3f\");\n      ImGui::InputFloat3(\"fbr\", (float*)&frustum.fbr, \"%.3f\");\n      ImGui::InputFloat(\"nearD\", (float*)&frustum.nearD, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"farD\", (float*)&frustum.farD, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"aspect\", (float*)&frustum.aspect, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"fovy\", (float*)&frustum.fovy, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"tang\", (float*)&frustum.tang, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"nw\", (float*)&frustum.nw, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"nh\", (float*)&frustum.nh, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"fw\", (float*)&frustum.fw, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n      ImGui::InputFloat(\"fh\", (float*)&frustum.fh, 1, 1, \"%.3f\",\n                        ImGuiInputTextFlags_ReadOnly);\n    }\n  }\n\n  if (ImGui::CollapsingHeader(\"Profiling\",\n#if DEBUG_PROFILING\n                              ImGuiTreeNodeFlags_DefaultOpen\n#else\n                              0\n#endif\n                              )) {\n    ImGui::Text(\"Frametime %.3f ms (%.1f FPS)\",\n                1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\n\n    ImGui::Text(\"Phys=%.3fms, Char=%.3f ms, Draw=%.3f ms, Path=%.3f ms\",\n                profAvgPhysics, profAvgCharacters, profAvgDraw, profAvgPath);\n    ImGui::InputInt(\"frustumCulled\", (int*)&frustumCulled, 0, 10,\n                    ImGuiInputTextFlags_ReadOnly);\n  }\n\n  Vec3d* goosePos = &Game_get()->player.goose->position;\n  if (ImGui::CollapsingHeader(\"Pathfinding\")) {\n#if DEBUG_PATHFINDING\n    ImGui::InputInt(\"debugPathfindingFrom\", (int*)&debugPathfindingFrom, 1, 10,\n                    inputFlags);\n    ImGui::InputInt(\"debugPathfindingTo\", (int*)&debugPathfindingTo, 1, 10,\n                    inputFlags);\n\n    if (ImGui::Button(\"print pos\")) {\n      printf(\"{%.3f, %.3f, %.3f}\\n\", goosePos->x, goosePos->y, goosePos->z);\n    }\n\n#endif\n  }\n\n#if ENABLE_NODEGRAPH_EDITOR\n  drawNodeGraphGUI(nodeGraph, goosePos, \"garden_map_graph\", \"garden_map_graph\",\n                   selectedNode);\n#endif\n\n  ImGui::End();\n}\n\nvoid drawString(const char* string, int x, int y) {\n  int w, h;\n  const char* c;\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n\n  glMatrixMode(GL_PROJECTION);\n  glPushMatrix();\n  glLoadIdentity();\n  w = glutGet(GLUT_WINDOW_WIDTH);\n  h = glutGet(GLUT_WINDOW_HEIGHT);\n  glOrtho(0, glutGet(GLUT_WINDOW_WIDTH), 0, glutGet(GLUT_WINDOW_HEIGHT), -1, 1);\n\n  glMatrixMode(GL_MODELVIEW);\n  glPushMatrix();\n  glLoadIdentity();\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glColor3f(1.0f, 1.0f, 1.0f);\n\n  glRasterPos2i(x, y);\n  for (c = string; *c != '\\0'; c++) {\n    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, *c);\n  }\n  glPopMatrix();  // GL_MODELVIEW\n\n  glMatrixMode(GL_PROJECTION);\n  glPopMatrix();  // GL_PROJECTION\n\n  glPopAttrib();  // GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT\n}\n\nvoid drawStringAtPoint(const char* string, Vec3d* pos, int centered) {\n  Vec3d screen;  // x, y, zdepth\n  bool success = worldCoordsToScreen(pos, &screen);\n  if (!success) {\n    return;\n  }\n\n  int stringLength;\n\n  stringLength = strlen(string);\n\n  drawString(string, screen.x - (centered ? (stringLength * 8 / 2) : 0.0),\n             screen.y);\n}\n\nvoid drawSprite(SpriteType spriteType,\n                int frame,\n                int x,\n                int y,\n                int width,\n                int height) {\n  const char* c;\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_POLYGON_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_CULL_FACE);\n\n  glMatrixMode(GL_PROJECTION);\n  glPushMatrix();\n  glLoadIdentity();\n  glOrtho(0, glutGet(GLUT_WINDOW_WIDTH), 0, glutGet(GLUT_WINDOW_HEIGHT), -1, 1);\n\n  glMatrixMode(GL_MODELVIEW);\n  glPushMatrix();\n  glLoadIdentity();\n  glDisable(GL_LIGHTING);\n\n  glTranslatef(x, y, 0);\n\n  glScalef(width, height, 1);\n\n  glEnable(GL_TEXTURE_2D);\n  glBindTexture(GL_TEXTURE_2D, sprites[spriteType].at(frame));\n  glBegin(GL_TRIANGLES);\n  for (int ivert = 0; ivert < spriteVertices.size(); ++ivert) {\n    glTexCoord2d(spriteUVs[ivert].x, spriteUVs[ivert].y);\n    glVertex3f(spriteVertices[ivert].x, spriteVertices[ivert].y,\n               spriteVertices[ivert].z);\n  }\n  glEnd();\n\n  glPopMatrix();  // GL_MODELVIEW\n\n  glMatrixMode(GL_PROJECTION);\n  glPopMatrix();  // GL_PROJECTION\n\n  glPopAttrib();  // GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n                  // GL_POLYGON_BIT\n}\n\nvoid drawSpriteAtPoint(SpriteType spriteType,\n                       int frame,\n                       int width,\n                       int height,\n                       Vec3d* pos,\n                       int centered) {\n  Vec3d screen;  // x, y, zdepth\n  bool success = worldCoordsToScreen(pos, &screen);\n  if (!success) {\n    return;\n  }\n\n  drawSprite(spriteType, frame, screen.x - (centered ? width / 2.0 : 0.0),\n             screen.y - (centered ? height / 2.0 : 0.0), width, height);\n}\n\nvoid drawMarker(float r, float g, float b, float radius) {\n  glPushAttrib(GL_LIGHTING_BIT | GL_TEXTURE_BIT | GL_CURRENT_BIT |\n               GL_DEPTH_BUFFER_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_DEPTH_TEST);\n  glColor3f(r, g, b);  // red\n  glutWireSphere(/*radius*/ radius, /*slices*/ 10, /*stacks*/ 10);\n  glPopAttrib();\n}\n\nvoid drawMarkerAtPoint(float r, float g, float b, float radius, Vec3d* pos) {\n  glPushMatrix();\n  glTranslatef(pos->x, pos->y, pos->z);\n  drawMarker(r, g, b, radius);\n  glPopMatrix();\n}\n\nvoid drawLine(Vec3d* start, Vec3d* end) {\n  glBegin(GL_LINES);\n  glVertex3f(start->x, start->y, start->z);\n  glVertex3f(end->x, end->y, end->z);\n  glEnd();\n}\n\nvoid drawMotionVectorLine(Vec3d* from, Vec3d* to) {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_DEPTH_BUFFER_BIT);\n  glPushMatrix();\n\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_DEPTH_TEST);\n  glColor3f(0.0f, 0.0f, 0.0f);  // blue\n  drawLine(from, to);\n  glPushMatrix();\n  glTranslatef(from->x, from->y, from->z);\n  drawMarker(0.8f, 0.0f, 0.0f, 1);  // from red\n  glPopMatrix();\n  glPushMatrix();\n  glTranslatef(to->x, to->y, to->z);\n  drawMarker(0.0f, 0.8f, 0.0f, 1);  // to green\n  glPopMatrix();\n  glPopAttrib();\n  glPopMatrix();\n}\n\nvoid drawTriNormal(Vec3d* normal, Vec3d* position) {\n  Vec3d from, to;\n\n  from = *position;\n  to = *normal;\n  Vec3d_mulScalar(&to, 20.0);\n  Vec3d_add(&to, position);\n\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_DEPTH_BUFFER_BIT);\n  glPushMatrix();\n\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_DEPTH_TEST);\n\n  glBegin(GL_LINES);\n  glColor3f(0.0f, 0.0f, 1.0f);\n  glVertex3f(from.x, from.y, from.z);\n  glColor3f(1.0f, 1.0f, 0.0f);\n  glVertex3f(to.x, to.y, to.z);\n  glEnd();\n\n  glPopAttrib();\n  glPopMatrix();\n}\n\nvoid drawRaycastLine(RaycastTraceEvent raycast) {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glPushMatrix();\n\n  // create end point based on origin and direction\n  Vec3d rayEnd = raycast.direction;\n  Vec3d_mulScalar(&rayEnd, 1000.0);\n  Vec3d_add(&rayEnd, &raycast.origin);\n\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  if (raycast.result) {\n    glColor3f(1.0f, 1.0f, 1.0f);\n  } else {\n    glColor3f(1.0f, 0.0f, 0.0f);\n  }\n  drawLine(&raycast.origin, &rayEnd);\n  glPushMatrix();\n  glTranslatef(raycast.origin.x, raycast.origin.y, raycast.origin.z);\n  drawMarker(0.8f, 0.8f, 0.8f, 1);\n  glPopMatrix();\n  glPushMatrix();\n  glTranslatef(rayEnd.x, rayEnd.y, rayEnd.z);\n  drawMarker(0.8f, 0.8f, 0.8f, 1);\n  glPopMatrix();\n  glPopAttrib();\n  glPopMatrix();\n}\n\nvoid drawPhysBall(float radius) {\n  glPushAttrib(GL_LIGHTING_BIT | GL_TEXTURE_BIT | GL_CURRENT_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n  glColor3f(1.0, 1.0, 0.0);  // yellow\n  glutWireSphere(/*radius*/ radius, /*slices*/ 10, /*stacks*/ 10);\n  glPopAttrib();\n}\n\nvoid Frustum_drawPoints(Frustum* frustum) {\n  glColor3f(1.0, 1.0, 0.0);  // yellow\n  glBegin(GL_POINTS);\n\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  glEnd();\n}\n\nvoid Frustum_drawLines(Frustum* frustum) {\n  glColor3f(1.0, 0.0, 0.0);\n  glBegin(GL_LINE_LOOP);\n  // near plane\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // far plane\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // bottom plane\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // top plane\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // left plane\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glEnd();\n\n  glBegin(GL_LINE_LOOP);\n  // right plane\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  glEnd();\n}\n\nvoid Frustum_drawPlanes(Frustum* frustum) {\n  glEnable(GL_BLEND);\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n  glColor4f(0.0f, 0.0, 1.0, 0.1);\n  glBegin(GL_QUADS);\n\n  // // near plane\n  // glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  // glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  // glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  // glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n\n  // // far plane\n  // glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  // glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  // glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  // glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  // // bottom plane\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n\n  // // top plane\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n\n  // left plane\n  glVertex3f(frustum->ntl.x, frustum->ntl.y, frustum->ntl.z);\n  glVertex3f(frustum->nbl.x, frustum->nbl.y, frustum->nbl.z);\n  glVertex3f(frustum->fbl.x, frustum->fbl.y, frustum->fbl.z);\n  glVertex3f(frustum->ftl.x, frustum->ftl.y, frustum->ftl.z);\n\n  // right plane\n  glVertex3f(frustum->nbr.x, frustum->nbr.y, frustum->nbr.z);\n  glVertex3f(frustum->ntr.x, frustum->ntr.y, frustum->ntr.z);\n  glVertex3f(frustum->ftr.x, frustum->ftr.y, frustum->ftr.z);\n  glVertex3f(frustum->fbr.x, frustum->fbr.y, frustum->fbr.z);\n\n  glDisable(GL_BLEND);\n  glEnd();\n}\n\nvoid drawMesh(ObjMesh& mesh, GLuint texture) {\n  glColor3f(1.0f, 1.0f, 1.0f);  // whitish\n  glEnable(GL_TEXTURE_2D);\n  glBindTexture(GL_TEXTURE_2D, texture);\n  glBegin(GL_TRIANGLES);\n  for (int ivert = 0; ivert < mesh.vertices.size(); ++ivert) {\n    glTexCoord2d(mesh.uvs[ivert].x, mesh.uvs[ivert].y);\n    glNormal3f(mesh.normals[ivert].x, mesh.normals[ivert].y,\n               mesh.normals[ivert].z);\n    glVertex3f(mesh.vertices[ivert].x, mesh.vertices[ivert].y,\n               mesh.vertices[ivert].z);\n  }\n  glEnd();\n  glDisable(GL_TEXTURE_2D);\n}\n\nObjMesh& getMeshForModelType(ModelType modelType, int subtype) {\n  try {\n    return models[modelType].meshList.at(subtype);\n  } catch (const std::out_of_range& oor) {\n    std::cerr << \"Out of Range error: \" << oor.what() << '\\n';\n  }\n  printf(\"did you forget to load \\\"%s\\\"?\\n\", ModelTypeStrings[modelType]);\n  invariant(false);\n}\n\nvoid drawMeshesForModel(ModelType modelType, int subtype) {\n  ObjModel& model = models[modelType];\n  ObjMesh& mesh = getMeshForModelType(modelType, subtype);\n  // draw mesh\n  drawMesh(mesh, model.texture);\n}\n\nchar* getMeshNameForModelMeshPart(ModelType modelType, int meshPart) {\n  switch (modelType) {\n    case GooseModel:\n      return GooseMeshTypeStrings[meshPart];\n    default:\n      return CharacterMeshTypeStrings[meshPart];\n  }\n}\n\nint getAnimationNumModelMeshParts(ModelType modelType) {\n  switch (modelType) {\n    case GooseModel:\n      return MAX_GOOSE_MESH_TYPE;\n    default:\n      return MAX_CHARACTER_MESH_TYPE;\n  }\n}\n\nAnimationRange* getCurrentAnimationRange(GameObject* obj) {\n  if (obj->modelType == GooseModel) {\n    return &goose_anim_ranges[(GooseAnimType)obj->animState->state];\n  } else {\n    return &character_anim_ranges[(CharacterAnimType)obj->animState->state];\n  }\n}\n\nAnimationFrame* getAnimData(ModelType modelType) {\n  switch (modelType) {\n    case GooseModel:\n      return goose_anim_data;\n    default:\n      return character_anim_data;\n  }\n}\n\nvoid drawModel(GameObject* obj) {\n  if (!obj->visible) {\n    return;\n  }\n\n  ObjModel& model = models[obj->modelType];\n\n  if (Renderer_isAnimatedGameObject(obj)) {\n    // case for multi-part objects using rigid body animation\n    // TODO: generalize this for other model types using other skeletons with\n    // retargetable animations\n\n    AnimationRange* curAnimRange;  // range of frames representing anim clip\n    AnimationInterpolation animInterp;  // interpolation value for frame\n    AnimationFrame animFrame;           // animation frame data for one bone\n    int modelMeshParts = getAnimationNumModelMeshParts(obj->modelType);\n\n    invariant(obj->animState != NULL);\n    curAnimRange = getCurrentAnimationRange(obj);\n\n#if DEBUG_ANIMATION\n    glDisable(GL_DEPTH_TEST);\n    drawMarker(1.0f, 0.0f, 0.0f, 5);  // origin marker, red\n    glEnable(GL_DEPTH_TEST);\n#endif\n\n    AnimationInterpolation_calc(&animInterp, obj->animState, curAnimRange);\n    for (int modelMeshIdx = 0; modelMeshIdx < modelMeshParts; ++modelMeshIdx) {\n#if USE_ANIM_FRAME_LERP\n      AnimationFrame_lerp(\n          &animInterp,  // result of AnimationInterpolation_calc()\n          getAnimData(\n              obj->modelType),  // pointer to start of AnimationFrame list\n          modelMeshParts,       // num bones in rig used by animData\n          modelMeshIdx,         // index of bone in rig to produce transform for\n          &animFrame            // the resultant interpolated animation frame\n      );\n#else\n      AnimationFrame_get(\n          &animInterp,  // result of AnimationInterpolation_calc()\n          getAnimData(\n              obj->modelType),  // pointer to start of AnimationFrame list\n          modelMeshParts,       // num bones in rig used by animData\n          modelMeshIdx,         // index of bone in rig to produce transform for\n          &animFrame);\n#endif\n\n      // push relative transformation matrix, render the mesh, then pop the\n      // relative transform off the matrix stack again\n      glPushMatrix();\n\n      // rotate from z-up (blender) to y-up (opengl) coords\n      glRotatef(-90.0f, 1, 0, 0);\n\n      glTranslatef(animFrame.position.x, animFrame.position.y,\n                   animFrame.position.z);\n\n      glRotatef(animFrame.rotation.x, 1, 0, 0);\n      glRotatef(animFrame.rotation.y, 0, 1, 0);\n      glRotatef(animFrame.rotation.z, 0, 0, 1);\n\n      char* meshName =\n          getMeshNameForModelMeshPart(obj->modelType, animFrame.object);\n      try {\n        ObjMesh& mesh = model.meshList.at(model.meshes.at(meshName));\n        drawMesh(mesh, model.texture);\n      } catch (const std::out_of_range& oor) {\n        std::cerr << \"missing mesh: \" << meshName << \" on model \"\n                  << ModelTypeStrings[obj->modelType] << \"\\n\";\n        invariant(false);\n      }\n\n      // attachment drawing stuff\n      AnimationBoneAttachment& attachment = obj->animState->attachment;\n      if (attachment.modelType != NoneModel &&\n          attachment.boneIndex == modelMeshIdx) {\n#if DEBUG_ATTACHMENT\n        printf(\n            \"drawing attachment %s on %s (animFrame.object=%d) at boneIdx=%d \"\n            \"mesh=%s\\n\",\n            ModelTypeStrings[attachment.modelType],\n            ModelTypeStrings[obj->modelType], animFrame.object,\n            attachment.boneIndex,\n            getMeshNameForModelMeshPart(obj->modelType, attachment.boneIndex));\n#endif\n        glPushMatrix();\n        glTranslatef(attachment.offset.x, attachment.offset.y,\n                     attachment.offset.z);\n        glRotatef(attachment.rotation.x, 1, 0, 0);\n        glRotatef(attachment.rotation.y, 0, 1, 0);\n        glRotatef(attachment.rotation.z, 0, 0, 1);\n        drawMeshesForModel(attachment.modelType, 0);\n        glPopMatrix();\n      }\n\n#if DEBUG_ANIMATION\n      glDisable(GL_DEPTH_TEST);\n      drawMarker(0.0f, 0.0f, 1.0f, 1);  // bone marker, blue\n      glEnable(GL_DEPTH_TEST);\n#endif\n\n#if DEBUG_ANIMATION_MORE\n      // overlay cones\n      glPushMatrix();\n      glRotatef(90.0f, 0, 0,\n                1);               // cone points towards z by default, flip up\n                                  // on the z axis to make cone point up at y\n      glRotatef(90.0f, 0, 1, 0);  // undo our weird global rotation\n      glDisable(GL_TEXTURE_2D);\n      glColor3f(1.0f, 0.0f, 0.0f);  // red\n      // glutSolidCone(4.2, 30, 4, 20);  // cone with 4 slices = pyramid-like\n\n      glColor3f(1.0f, 1.0f, 1.0f);\n      glEnable(GL_TEXTURE_2D);\n      glPopMatrix();\n\n      // overlay text\n      glPushMatrix();\n      Vec3d animFrameGlobalPos;\n      Vec3d_origin(&animFrameGlobalPos);\n      drawStringAtPoint(\n          getMeshNameForModelMeshPart(obj->modelType, animFrame.object),\n          &animFrameGlobalPos, FALSE);\n      glPopMatrix();\n#endif\n\n      glPopMatrix();\n    }\n\n  } else {\n    // case for simple gameobjects with no moving sub-parts\n    drawMeshesForModel(obj->modelType, obj->subtype);\n#if DEBUG_MODELS\n    drawMarker(255.0, 0.0, 255.0, 1);  // obj marker, purple\n#endif\n  }\n}\n\nvoid resizeWindow(int w, int h) {\n  ImGui_ImplGLUT_ReshapeFunc(w, h);\n  // Prevent a divide by zero, when window is too short\n  // (you cant make a window of zero width).\n  if (h == 0)\n    h = 1;\n  aspect = w * 1.0 / h;\n\n  // Use the Projection Matrix\n  glMatrixMode(GL_PROJECTION);\n  // Reset Matrix\n  glLoadIdentity();\n  // Set the viewport to be the entire window\n  glViewport(0, 0, w, h);\n  // Set the correct perspective.\n  gluPerspective(fovy, aspect, nearPlane,\n                 Game_get()->freeView ? 10000 : farPlane);\n  Frustum_setCamInternals(&frustum, fovy, aspect, nearPlane, farPlane);\n  // Get Back to the Modelview\n  glMatrixMode(GL_MODELVIEW);\n}\n\nvoid enableLighting() {\n  GLfloat light_ambient[] = {0.1f, 0.1f, 0.1f, 1.0f};   /* default value */\n  GLfloat light_diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f};   /* default value */\n  GLfloat light_specular[] = {1.0f, 1.0f, 1.0f, 1.0f};  /* default value */\n  GLfloat light_position[] = {1.0f, 1.0f, -1.0f, 0.0f}; /* NOT default value */\n  GLfloat lightModel_ambient[] = {0.2f, 0.2f, 0.2f, 1.0f}; /* default value */\n  GLfloat material_specular[] = {1.0f, 1.0f, 1.0f,\n                                 1.0f}; /* NOT default value */\n  GLfloat material_emission[] = {0.0f, 0.0f, 0.0f, 1.0f}; /* default value */\n  glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);\n  glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);\n  glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);\n  glLightfv(GL_LIGHT0, GL_POSITION, light_position);\n  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lightModel_ambient);\n  glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);\n  glMaterialfv(GL_FRONT, GL_SPECULAR, material_specular);\n  glMaterialfv(GL_FRONT, GL_EMISSION, material_emission);\n  glMaterialf(GL_FRONT, GL_SHININESS, 10.0); /* NOT default value   */\n  glEnable(GL_LIGHTING);\n  glEnable(GL_LIGHT0);\n  glEnable(GL_NORMALIZE);\n  glEnable(GL_COLOR_MATERIAL);\n}\n\nvoid drawGameObject(GameObject* obj, bool useZBuffering) {\n  Vec3d pos, centroidOffset;\n  pos = obj->position;\n  centroidOffset = modelTypesProperties[obj->modelType].centroidOffset;\n\n  glPushMatrix();\n  glTranslatef(pos.x, pos.y, pos.z);\n  glRotatef(obj->rotation.y, 0, 1, 0);\n  glScalef(modelTypesProperties[obj->modelType].scale,\n           modelTypesProperties[obj->modelType].scale,\n           modelTypesProperties[obj->modelType].scale);\n\n  if (obj->modelType != NoneModel) {\n#if RENDERER_PAINTERS_ALGORITHM\n    if (useZBuffering) {\n      glEnable(GL_DEPTH_TEST);\n    } else {\n      glDisable(GL_DEPTH_TEST);\n    }\n#else\n    glEnable(GL_DEPTH_TEST);\n#endif\n#if USE_LIGHTING_STATIC_ONLY\n    if (Renderer_isLitGameObject(obj)) {\n      glEnable(GL_LIGHTING);\n    } else {\n      glDisable(GL_LIGHTING);\n    }\n#endif\n    drawModel(obj);\n  }\n  glPopMatrix();\n}\n\nvoid drawAABB(AABB* aabb) {\n  // top\n  glBegin(GL_LINE_LOOP);\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->min.z);\n  glEnd();\n\n  // bottom\n  glBegin(GL_LINE_LOOP);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->max.z);\n  glEnd();\n\n  // sides\n  glBegin(GL_LINES);\n  // 1\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->min.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->min.z);\n  // 2\n  glVertex3f(aabb->min.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->min.x, aabb->max.y, aabb->max.z);\n  // 3\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->max.z);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->max.z);\n  // 4\n  glVertex3f(aabb->max.x, aabb->min.y, aabb->min.z);\n  glVertex3f(aabb->max.x, aabb->max.y, aabb->min.z);\n  glEnd();\n}\n\nvoid drawAABBColored(AABB* aabb, float r, float g, float b) {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n  glColor3f(r, g, b);\n  drawAABB(aabb);\n  glPopAttrib();\n}\n\nvoid drawPlane(Plane* plane, Vec3d* up) {\n  glPushAttrib(GL_LIGHTING_BIT | GL_TEXTURE_BIT | GL_CURRENT_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n\n  Vec3d third;\n  Vec3d_cross(&plane->normal, up, &third);\n\n  glPushMatrix();\n  glTranslatef(plane->point.x, plane->point.y, plane->point.z);\n  drawMarker(0.5f * 0.8, 0.0f, 0.0f, 1);\n  glPopMatrix();\n\n  Vec3d normalScaled = plane->normal;\n  Vec3d_mulScalar(&normalScaled, 10);\n  Vec3d_add(&normalScaled, &plane->point);\n  glColor3f(0, 0, 1);\n  drawLine(&plane->point, &normalScaled);\n\n  Vec3d upScaled = *up;\n  Vec3d_mulScalar(&upScaled, 10);\n  Vec3d_add(&upScaled, &plane->point);\n  glColor3f(1, 0, 0);\n  drawLine(&plane->point, &upScaled);\n\n  Vec3d thirdScaled = third;\n  Vec3d_mulScalar(&thirdScaled, 10);\n  Vec3d_add(&thirdScaled, &plane->point);\n  glColor3f(0, 1, 0);\n  drawLine(&plane->point, &thirdScaled);\n\n  glPopAttrib();\n}\n\nvoid drawSpatialHashCell(int cellBaseX, int cellBaseY) {\n  AABB cellAABB;\n  cellAABB.min.x = SpatialHash_gridToUnitsForDimension(\n      cellBaseX, physWorldData.worldMeshSpatialHash);\n  cellAABB.min.y = 0;\n  cellAABB.min.z = -SpatialHash_gridToUnitsForDimension(\n      cellBaseY, physWorldData.worldMeshSpatialHash);\n  cellAABB.max.x = SpatialHash_gridToUnitsForDimension(\n      cellBaseX + 1, physWorldData.worldMeshSpatialHash);\n  cellAABB.max.y = 0;\n  cellAABB.max.z = -SpatialHash_gridToUnitsForDimension(\n      cellBaseY + 1, physWorldData.worldMeshSpatialHash);\n\n  drawAABBColored(&cellAABB, 1.0, 1.0, 0.0);\n}\n\nvoid spatialHashTraversalVisitor(int x, int y, void* traversalState) {\n  drawSpatialHashCell(x, y);\n}\n\nvoid drawCollisionMesh() {\n  int i;\n\n  Triangle* tri;\n  Vec3d triCentroid, triNormal;\n  char triIndexText[100];\n\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_DEPTH_BUFFER_BIT | GL_POLYGON_BIT);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_LIGHTING);\n\n  // draw on top of everything else\n  glDisable(GL_DEPTH_TEST);\n\n  glPushMatrix();\n\n  // draw all tris wireframes\n  float triColor;\n  for (i = 0, tri = garden_map_collision_collision_mesh;\n       i < GARDEN_MAP_COLLISION_LENGTH; i++, tri++) {\n    triColor = (i / (float)GARDEN_MAP_COLLISION_LENGTH);\n    glColor3f(0.0f, triColor, 1.0f - triColor);\n    glBegin(GL_LINE_LOOP);\n    glVertex3f(tri->a.x, tri->a.y, tri->a.z);\n    glVertex3f(tri->b.x, tri->b.y, tri->b.z);\n    glVertex3f(tri->c.x, tri->c.y, tri->c.z);\n    glEnd();\n  }\n\n  // draw spatial hash matching tris\n  if (selectedObject) {\n    int spatialHashResults[100];\n    int spatialHashResultsCount;\n    Vec3d selectedObjCenter;\n    Game_getObjCenter(selectedObject, &selectedObjCenter);\n\n    spatialHashResultsCount = SpatialHash_getTriangles(\n        &selectedObjCenter, Game_getObjRadius(selectedObject),\n        physWorldData.worldMeshSpatialHash, spatialHashResults,\n        /*maxResults*/ 100);\n\n#if DEBUG_COLLISION_SPATIAL_HASH_RAYCAST\n    Vec3d testRayEnd = {0, 25, 0};\n    GameUtils_directionFromTopDownAngle(degToRad(selectedObject->rotation.y),\n                                        &testRayEnd);\n    Vec3d_mulScalar(&testRayEnd, 600);\n    Vec3d_add(&testRayEnd, &selectedObjCenter);\n\n    glColor3f(1.0f, 0.0f, 0.0f);  // red\n    drawLine(&selectedObjCenter, &testRayEnd);\n\n    // draw raycast in front of selected object\n    spatialHashResultsCount = SpatialHash_getTrianglesForRaycast(\n        &selectedObjCenter, &testRayEnd, physWorldData.worldMeshSpatialHash,\n        spatialHashResults,\n        /*maxResults*/ 1000);\n\n    // draw current cell\n    float cellBaseX = SpatialHash_unitsToGridFloatForDimension(\n        selectedObjCenter.x, physWorldData.worldMeshSpatialHash);\n    float cellBaseY = SpatialHash_unitsToGridFloatForDimension(\n        -selectedObjCenter.z, physWorldData.worldMeshSpatialHash);\n    // drawSpatialHashCell(cellBaseX, cellBaseY);\n    SpatialHash_raycast(cellBaseX, cellBaseY,\n                        SpatialHash_unitsToGridFloatForDimension(\n                            testRayEnd.x, physWorldData.worldMeshSpatialHash),\n                        SpatialHash_unitsToGridFloatForDimension(\n                            -testRayEnd.z, physWorldData.worldMeshSpatialHash),\n                        &spatialHashTraversalVisitor, (void*)NULL);\n#endif\n\n#if DEBUG_COLLISION_SPATIAL_HASH_TRIS\n    int i;\n    for (i = 0; i < spatialHashResultsCount; i++) {\n      glEnable(GL_BLEND);\n      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n      for (i = 0; i < spatialHashResultsCount; i++) {\n        tri = garden_map_collision_collision_mesh + spatialHashResults[i];\n        triColor = (spatialHashResults[i] / (float)GARDEN_MAP_COLLISION_LENGTH);\n\n        glColor4f(0.0f, triColor * 0.8, (1.0f - triColor) * 0.8, 0.3);\n        glBegin(GL_TRIANGLES);\n        glVertex3f(tri->a.x, tri->a.y, tri->a.z);\n        glVertex3f(tri->b.x, tri->b.y, tri->b.z);\n        glVertex3f(tri->c.x, tri->c.y, tri->c.z);\n        glEnd();\n      }\n      glDisable(GL_BLEND);\n    }\n#endif\n\n    // draw cells selected object is in\n    int minCellX = SpatialHash_unitsToGridForDimension(\n        selectedObjCenter.x - Game_getObjRadius(selectedObject),\n        physWorldData.worldMeshSpatialHash);\n    int minCellY = SpatialHash_unitsToGridForDimension(\n        -selectedObjCenter.z - Game_getObjRadius(selectedObject),\n        physWorldData.worldMeshSpatialHash);\n    int maxCellX = SpatialHash_unitsToGridForDimension(\n                       selectedObjCenter.x + Game_getObjRadius(selectedObject),\n                       physWorldData.worldMeshSpatialHash) +\n                   1;\n    int maxCellY = SpatialHash_unitsToGridForDimension(\n                       -selectedObjCenter.z + Game_getObjRadius(selectedObject),\n                       physWorldData.worldMeshSpatialHash) +\n                   1;\n\n    // draw overlapping cells\n    for (int cellX = minCellX; cellX < maxCellX; ++cellX) {\n      for (int cellY = minCellY; cellY < maxCellY; ++cellY) {\n        drawSpatialHashCell(cellX, cellY);\n      }\n    }\n\n#if DEBUG_COLLISION_MESH_AABB || DEBUG_COLLISION_SPATIAL_HASH_RAYCAST\n    for (i = 0; i < spatialHashResultsCount; i++) {\n      tri = garden_map_collision_collision_mesh + spatialHashResults[i];\n      AABB triangleAABB;\n      AABB_fromTriangle(tri, &triangleAABB);\n\n#if DEBUG_COLLISION_SPATIAL_HASH_RAYCAST\n      if (Collision_testSegmentAABBCollision(&selectedObjCenter, &testRayEnd,\n                                             &triangleAABB)) {\n        drawAABBColored(&triangleAABB, 1.0, 0.0, 0.0);  // red, collision\n      } else {\n        drawAABBColored(&triangleAABB, 1.0, 1.0, 0.0);  // yellow\n      }\n#else\n      drawAABBColored(&triangleAABB, 1.0, 1.0, 0.0);  // yellow\n#endif\n    }\n#endif\n  }\n\n  // draw collided tris\n  if (testCollisionResults.size()) {\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    std::map<int, SphereTriangleCollision>::iterator collIter =\n        testCollisionResults.begin();\n\n    while (collIter != testCollisionResults.end()) {\n      tri = garden_map_collision_collision_mesh + collIter->first;\n\n      if (testCollisionResult == collIter->first) {\n        glColor4f(1.0f, 0.0f, 0.0f, 0.3);\n      } else {\n        glColor4f(1.0f, 1.0f, 0.0f, 0.3);\n      }\n      glBegin(GL_TRIANGLES);\n      glVertex3f(tri->a.x, tri->a.y, tri->a.z);\n      glVertex3f(tri->b.x, tri->b.y, tri->b.z);\n      glVertex3f(tri->c.x, tri->c.y, tri->c.z);\n      glEnd();\n\n      collIter++;\n    }\n    glDisable(GL_BLEND);\n  }\n\n// draw tri labels & normals\n#if DEBUG_COLLISION_MESH_MORE\n  for (i = 0, tri = garden_map_collision_collision_mesh;\n       i < GARDEN_MAP_COLLISION_LENGTH; i++, tri++) {\n    triColor = (i / (float)GARDEN_MAP_COLLISION_LENGTH);\n    Triangle_getCentroid(tri, &triCentroid);\n    Triangle_getNormal(tri, &triNormal);\n\n    float triCollisionDistance = 0;\n    if (testCollisionResults.count(i) > 0) {\n      try {\n        SphereTriangleCollision& collisionTestResult =\n            testCollisionResults.at(i);\n\n        // marker showing closest hit point in triangle\n        Vec3d& hitPos = collisionTestResult.posInTriangle;\n        glPushMatrix();\n        glTranslatef(hitPos.x, hitPos.y, hitPos.z);\n        if (testCollisionResult == i) {\n          drawMarker(0.5f * 0.8, 0.0f, 0.0f, 1);\n        } else {\n          drawMarker(0.0f, triColor * 0.8, (1.0f - triColor) * 0.8, 1);\n        }\n        glPopMatrix();\n\n        // text label\n        triCollisionDistance = collisionTestResult.distance;\n        sprintf(triIndexText, \"%d: %.2f %s\", i, triCollisionDistance,\n                i == testCollisionResult ? \"[closest]\" : \"\");\n        drawStringAtPoint(triIndexText, &triCentroid, TRUE);\n      } catch (const std::out_of_range& oor) {\n        std::cerr << \"missing SphereTriangleCollision: \" << i << \"\\n\";\n      }\n    } else {\n      // print other tri indexes\n      sprintf(triIndexText, \"%d \", i);\n      drawStringAtPoint(triIndexText, &triCentroid, TRUE);\n    }\n\n    drawTriNormal(&triNormal, &triCentroid);\n  }\n#endif\n\n  glPopMatrix();\n  glPopAttrib();\n}\n\nvoid doTestPathfinding(int printResult) {\n  float profStartPath = CUR_TIME_MS();\n\n#if DEBUG_PATHFINDING_AUTO\n  Vec3d* goosePos = &Game_get()->player.goose->position;\n  Vec3d* characterPos = &Game_get()->characters->obj->position;\n  debugPathfindingTo = Path_quantizePosition(pathfindingGraph, goosePos);\n  debugPathfindingFrom = Path_quantizePosition(pathfindingGraph, characterPos);\n#else\n  debugPathfindingTo = CLAMP(debugPathfindingTo, 0, pathfindingGraph->size - 1);\n  debugPathfindingFrom =\n      CLAMP(debugPathfindingFrom, 0, pathfindingGraph->size - 1);\n#endif\n\n  Path_initState(\n      pathfindingGraph,                                          // graph\n      pathfindingState,                                          // state\n      Path_getNodeByID(pathfindingGraph, debugPathfindingFrom),  // start\n      Path_getNodeByID(pathfindingGraph, debugPathfindingTo),    // end\n      pathfindingState->nodeStates,     // nodeStates array\n      pathfindingState->nodeStateSize,  // nodeStateSize\n      pathfindingState->result          // results array\n  );\n\n  int result = Path_findAStar(pathfindingGraph, pathfindingState);\n\n  float profTimePath = (CUR_TIME_MS() - profStartPath);\n  Game_get()->profTimePath += profTimePath;\n\n  if (printResult) {\n    printf(\"finding path from %d to %d\\n\", pathfindingState->start->id,\n           pathfindingState->end->id);\n    printf(\"pathfinding result %s\\n\", result ? \"found\" : \"not found\");\n    printf(\"pathfinding took %f\\n\", profTimePath);\n    if (result) {\n      printf(\"pathfinding result length %d\\n\", pathfindingState->resultSize);\n\n      // pathfinding result path\n      for (int i = 0; i < pathfindingState->resultSize; i++) {\n        printf(\"%d: %d\\n\", i, *(pathfindingState->result + i));\n      }\n    }\n  }\n}\n\nvoid drawPathfindingGraph() {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n\n  Node* node;\n  Node* endNode;\n  Graph* graph = pathfindingGraph;\n  PathfindingState* state = pathfindingState;\n  int i, k;\n  int* reachedViaNodeID;\n\n  // draw graph edges\n  for (i = 0, node = graph->nodes;  //\n       i < graph->size;             //\n       i++, node++                  //\n  ) {\n    EdgeList* edges = Path_getNodeEdgesByID(graph, i);\n\n    // Loop through each edge in turn.\n    for (                                           //\n        k = 0, reachedViaNodeID = edges->elements;  //\n        k < edges->size;                            //\n        k++, reachedViaNodeID++                     //\n    ) {\n      endNode = Path_getNodeByID(graph, *reachedViaNodeID);\n      glColor3f(0.5f, 0.5f, 0.5f);  // grey\n      drawLine(&node->position, &endNode->position);\n    }\n  }\n\n  // draw pathfinding result path\n  for (i = 0;                      //\n       i < state->resultSize - 1;  //\n       i++                         //\n  ) {\n    node = Path_getNodeByID(graph, *(state->result + i));\n    endNode = Path_getNodeByID(graph, *(state->result + i + 1));\n\n    glColor3f(1.0f, 0.0f, 0.0f);  // red\n    drawLine(&node->position, &endNode->position);\n  }\n\n  // draw graph nodes\n  for (i = 0, node = graph->nodes;  //\n       i < graph->size;             //\n       i++, node++                  //\n  ) {\n    glPushMatrix();\n    glTranslatef(node->position.x, node->position.y, node->position.z);\n    glColor3f(1.0f, 0.7f, 0.0f);  // orange\n    glutSolidCube(10);\n    glPopMatrix();\n  }\n\n  for (i = 0, node = graph->nodes;  //\n       i < graph->size;             //\n       i++, node++                  //\n  ) {\n    drawStringAtPoint(std::to_string(i).c_str(), &node->position, TRUE);\n  }\n\n  Character* selectedCharacter = selectedObject == Game_get()->characters->obj\n                                     ? Game_get()->characters\n                                     : NULL;\n  if (selectedCharacter) {\n    glPushMatrix();\n    glTranslatef(selectedCharacter->targetLocation.x,\n                 selectedCharacter->targetLocation.y,\n                 selectedCharacter->targetLocation.z);\n    glColor3f(0.0f, 0.0f, 1.0f);  // blue\n    glutSolidCube(10);\n    glPopMatrix();\n    glPushMatrix();\n    glTranslatef(selectedCharacter->movementTarget.x,\n                 selectedCharacter->movementTarget.y,\n                 selectedCharacter->movementTarget.z);\n    glColor3f(1.0f, 0.0f, 0.0f);  // red\n    glutSolidCube(10);\n    glPopMatrix();\n  }\n\n  glPopAttrib();\n}\n\nvoid drawNodeGraph() {\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n\n  Node* node;\n  Node* endNode;\n  int i;\n\n  // draw graph edges\n  for (auto edge = nodeGraph.edges.begin(); edge != nodeGraph.edges.end();\n       ++edge) {\n    node = &nodeGraph.nodes[edge->from];\n    endNode = &nodeGraph.nodes[edge->to];\n\n    glColor3f(0.5f, 0.5f, 0.5f);  // grey\n    drawLine(&node->position, &endNode->position);\n  }\n\n  // draw graph nodes\n  for (auto node = nodeGraph.nodes.begin(); node != nodeGraph.nodes.end();\n       ++node) {\n    glPushMatrix();\n    glTranslatef(node->position.x, node->position.y, node->position.z);\n    if (node->id == selectedNode) {\n      glColor3f(1.0f, 0.0f, 0.0f);  // red\n    } else {\n      glColor3f(1.0f, 0.7f, 0.0f);  // orange\n    }\n    glutSolidCube(10);\n    glPopMatrix();\n  }\n\n  // draw graph node ids\n  i = 0;\n  for (auto node = nodeGraph.nodes.begin(); node != nodeGraph.nodes.end();\n       ++node) {\n    drawStringAtPoint(std::to_string(i).c_str(), &node->position, TRUE);\n    i++;\n  }\n\n  glPopAttrib();\n}\n\nvoid renderScene(void) {\n  int i;\n  Game* game;\n\n  float profStartDraw = CUR_TIME_MS();\n\n  // Start the Dear ImGui frame\n  ImGui_ImplOpenGL2_NewFrame();\n  ImGui_ImplGLUT_NewFrame();\n\n  game = Game_get();\n\n  // glClearColor(0, 0, 0, 1);\n\n  glClearColor(112 / 255.0, 158 / 255.0, 122 / 255.0, 1);\n  // Clear Color and Depth Buffers\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  // Use the Projection Matrix\n  glMatrixMode(GL_PROJECTION);\n  int w = glutGet(GLUT_WINDOW_WIDTH);\n  int h = glutGet(GLUT_WINDOW_HEIGHT);\n  float aspect = w / h;\n  resizeWindow(w, h);\n\n  // Reset transformations\n  glLoadIdentity();\n\n  // Set the camera\n  Frustum_setCamDef(&frustum, &game->viewPos, &game->viewTarget, &upVector);\n  if (game->freeView) {\n    gluLookAt(                                        //\n        freeViewPos.x, freeViewPos.y, freeViewPos.z,  // eye\n        freeViewPos.x + cameraLX, freeViewPos.y,\n        freeViewPos.z + cameraLZ,           // center\n        upVector.x, upVector.y, upVector.z  // up\n    );\n  } else {\n    gluLookAt(                                                       //\n        game->viewPos.x, game->viewPos.y, game->viewPos.z,           // eye\n        game->viewTarget.x, game->viewTarget.y, game->viewTarget.z,  // center\n        upVector.x, upVector.y, upVector.z                           // up\n    );\n  }\n\n  // store the viewport for later\n  glGetDoublev(GL_MODELVIEW_MATRIX, lastModelView);\n  glGetDoublev(GL_PROJECTION_MATRIX, lastProjection);\n  glGetIntegerv(GL_VIEWPORT, lastViewport);\n\n  int* worldObjectsVisibility =\n      (int*)malloc(game->worldObjectsCount * sizeof(int));\n  if (!worldObjectsVisibility) {\n    debugPrintf(\"failed to alloc worldObjectsVisibility\");\n  }\n\n  int visibilityCulled =\n      Renderer_cullVisibility(game->worldObjects, game->worldObjectsCount,\n                              worldObjectsVisibility, &frustum, localAABBs);\n  frustumCulled = visibilityCulled;\n\n  // only alloc space for num visible objects\n  int visibleObjectsCount = game->worldObjectsCount - visibilityCulled;\n  RendererSortDistance* visibleObjDist = (RendererSortDistance*)malloc(\n      (visibleObjectsCount) * sizeof(RendererSortDistance));\n  if (!visibleObjDist) {\n    debugPrintf(\"failed to alloc visibleObjDist\");\n  }\n  Renderer_sortVisibleObjects(\n      game->worldObjects, game->worldObjectsCount, worldObjectsVisibility,\n      visibleObjectsCount, visibleObjDist, &game->viewPos, garden_map_bounds);\n\n  // boolean of whether an object intersects another (for z buffer optimization)\n  int* intersectingObjects = (int*)malloc((visibleObjectsCount) * sizeof(int));\n  invariant(intersectingObjects);\n  Renderer_calcIntersecting(intersectingObjects, visibleObjectsCount,\n                            visibleObjDist, garden_map_bounds);\n\n#if USE_LIGHTING\n  enableLighting();\n#endif\n\n#if USE_FLAT_SHADING\n  glShadeModel(GL_FLAT);\n#endif\n\n#if DEBUG_LOG_RENDER\n  printf(\"draw start\\n\");\n#endif\n  // render visible objects\n  for (i = 0; i < visibleObjectsCount; i++) {\n    GameObject* obj = (visibleObjDist + i)->obj;\n#if DEBUG_LOG_RENDER\n    printf(\"draw obj %d %s dist=%.3f {x:%.3f, y:%.3f, z:%.3f}\\n\", obj->id,\n           ModelTypeStrings[obj->modelType],\n           Vec3d_distanceTo(&(obj->position), &viewPos), obj->position.x,\n           obj->position.y, obj->position.z);\n#endif\n    drawGameObject(\n        obj,\n        // useZBuffering\n        intersectingObjects[i] ||\n            // animated game objects have concave shapes, need z buffering\n            Renderer_isAnimatedGameObject(obj)\n\n    );\n  }\n\n#if USE_SPRITES\n\n  // draw sprite attachments\n  for (i = 0; i < visibleObjectsCount; i++) {\n    GameObject* obj = (visibleObjDist + i)->obj;\n\n    if (obj->animState) {\n      AnimationBoneSpriteAttachment& sprAttachment =\n          obj->animState->spriteAttachment;\n\n      drawSpriteAtPoint(sprAttachment.spriteType, 0, 100, 100, &obj->position,\n                        TRUE);\n    }\n  }\n#endif\n\n#if USE_LIGHTING\n  glEnable(GL_LIGHTING);\n#endif\n#if USE_FLAT_SHADING\n  glShadeModel(GL_SMOOTH);\n#endif\n\n#if DEBUG_COLLISION_MESH || DEBUG_COLLISION_MESH_MORE || \\\n    DEBUG_COLLISION_SPATIAL_HASH || DEBUG_COLLISION_MESH_AABB\n  drawCollisionMesh();\n#endif\n\n#if DEBUG_AABB\n  for (i = 0; i < game->worldObjectsCount; i++) {\n    GameObject* obj = game->worldObjects + i;\n    AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n    drawAABBColored(&worldAABB, 0.8, 0.8, 0.8);\n\n#if DEBUG_FRUSTUM\n    FrustumTestResult frustumTestResult;\n    if (frustumPlaneToTest > -1) {\n      Vec3d vertexP, vertexN;\n      Frustum_getAABBVertexP(\n          &worldAABB, &frustum.planes[frustumPlaneToTest].normal, &vertexP);\n      Frustum_getAABBVertexN(\n          &worldAABB, &frustum.planes[frustumPlaneToTest].normal, &vertexN);\n      frustumTestResult = Frustum_boxFrustumPlaneTestPN(&frustum, &worldAABB,\n                                                        frustumPlaneToTest);\n      glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n                   GL_POLYGON_BIT);\n      glDisable(GL_DEPTH_TEST);\n      glDisable(GL_LIGHTING);\n      glDisable(GL_TEXTURE_2D);\n      // glDisable(GL_CULL_FACE);\n\n      glPushMatrix();\n      glTranslatef(vertexP.x, vertexP.y, vertexP.z);\n      glColor3f(1.0, 0.0, 0.0);\n      glutSolidCube(2);\n      glPopMatrix();\n\n      glPushMatrix();\n      glTranslatef(vertexN.x, vertexN.y, vertexN.z);\n      glColor3f(0.0, 1.0, 0.0);\n      glutSolidCube(2);\n      glPopMatrix();\n    } else {\n      frustumTestResult = Frustum_boxInFrustum(&frustum, &worldAABB);\n    }\n    drawStringAtPoint(FrustumTestResultStrings[frustumTestResult],\n                      &obj->position, TRUE);\n\n#endif\n  }\n#endif\n\n#if DEBUG_PAINTERS_ALGORITHM_SEPARATING_PLANE\n  if (selectedObject) {\n    GameObject* a = game->player.goose;\n    GameObject* b = selectedObject;\n    Plane separatingPlane;\n    Vec3d aCenter, bCenter, aClosestPoint, bClosestPoint, aReallyClosestPoint,\n        bReallyClosestPoint;\n    AABB aabbA = Renderer_getWorldAABB(localAABBs, a);\n    AABB aabbB = Renderer_getWorldAABB(localAABBs, b);\n    float planeToADist, planeToViewDist;\n    Game_getObjCenter(a, &aCenter);\n    Game_getObjCenter(b, &bCenter);\n    if (Renderer_isDynamicObject(a)) {\n      aClosestPoint = aCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbA, &bCenter, &aClosestPoint);\n    }\n    if (Renderer_isDynamicObject(b)) {\n      bClosestPoint = bCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbB, &aCenter, &bClosestPoint);\n    }\n\n    if (Renderer_isDynamicObject(a)) {\n      aReallyClosestPoint = aCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbA, &bClosestPoint, &aReallyClosestPoint);\n    }\n    if (Renderer_isDynamicObject(b)) {\n      bReallyClosestPoint = bCenter;\n    } else {\n      Renderer_closestPointOnAABB(&aabbB, &aClosestPoint, &bReallyClosestPoint);\n    }\n\n    Renderer_getSeparatingPlane(&aReallyClosestPoint, &bReallyClosestPoint,\n                                &separatingPlane);\n\n    drawPlane(&separatingPlane, &upVector);\n    drawMotionVectorLine(&aReallyClosestPoint, &bReallyClosestPoint);\n\n    drawMotionVectorLine(&aCenter, &separatingPlane.point);\n\n    drawTriNormal(&separatingPlane.normal, &separatingPlane.point);\n\n    Vec3d closestPointOnPlane;\n    Plane_pointClosestPoint(&separatingPlane, &aReallyClosestPoint,\n                            &closestPointOnPlane);\n    drawMarkerAtPoint(1, 1, 0, 1, &closestPointOnPlane);\n  }\n\n#endif\n\n#if DEBUG_ZBUFFER_INTERSECTING\n  {\n    for (int i = 0; i < visibleObjectsCount; ++i) {\n      GameObject* obj = (visibleObjDist + i)->obj;\n      AABB worldAABB = Renderer_getWorldAABB(localAABBs, obj);\n\n      drawAABBColored(&worldAABB, 0.8, 0.8, 0.8);  // grey\n      drawStringAtPoint(\n          intersectingObjects[i] ? \"ZB:Intersecting\" : \"ZB:Disjoint\",\n          &obj->position, TRUE);\n    }\n  }\n#endif\n\n#if DEBUG_PHYSICS\n  PhysBody* body;\n  for (i = 0, body = game->physicsBodies; i < game->physicsBodiesCount;\n       i++, body++) {\n    glPushMatrix();\n    glTranslatef(body->position.x, body->position.y, body->position.z);\n    drawPhysBall(body->radius);\n    glPopMatrix();\n    drawMotionVectorLine(&body->prevPosition, &body->position);\n  }\n#endif\n\n#if DEBUG_RAYCASTING\n  for (i = 0; i < gameRaycastTrace.size(); ++i) {\n    drawRaycastLine(gameRaycastTrace[i]);\n  }\n\n#endif\n  gameRaycastTrace.clear();\n\n#if DEBUG_PATHFINDING_GRAPH\n  drawPathfindingGraph();\n#endif\n#if ENABLE_NODEGRAPH_EDITOR\n  drawNodeGraph();\n#endif\n\n#if DEBUG_FRUSTUM\n  glPushMatrix();\n  glPushAttrib(GL_TRANSFORM_BIT | GL_LIGHTING_BIT | GL_TEXTURE_BIT |\n               GL_POLYGON_BIT);\n  // glEnable(GL_DEPTH_TEST);\n  glDisable(GL_LIGHTING);\n  glDisable(GL_TEXTURE_2D);\n  glDisable(GL_CULL_FACE);\n  Frustum_drawPoints(&frustum);\n  Frustum_drawLines(&frustum);\n  Frustum_drawPlanes(&frustum);\n\n  glPopMatrix();\n  glPopAttrib();\n#endif\n\n#if DEBUG_OBJECTS\n  char objdebugtext[300];\n  for (i = 0; i < game->worldObjectsCount; i++) {\n    GameObject* obj = game->worldObjects + i;\n    strcpy(objdebugtext, \"\");\n\n    sprintf(objdebugtext, \"%d: %s\", obj->id, ModelTypeStrings[obj->modelType]);\n\n    drawStringAtPoint(objdebugtext, &obj->position, TRUE);\n\n    Vec3d objCenter;\n    Game_getObjCenter(obj, &objCenter);\n\n    glPushMatrix();\n    glTranslatef(objCenter.x, objCenter.y, objCenter.z);\n    drawMarker(0.2, 0.2, 0.2, Game_getObjRadius(obj));\n    glPopMatrix();\n  }\n#endif\n\n  if (selectedObject) {\n    Vec3d selObjCenter;\n    Game_getObjCenter(selectedObject, &selObjCenter);\n\n    glPushMatrix();\n    glTranslatef(selObjCenter.x, selObjCenter.y, selObjCenter.z);\n    drawMarker(1.0, 0.5, 0.0, Game_getObjRadius(selectedObject));\n    glPopMatrix();\n  }\n\n  char pausedtext[80];\n  if (game->paused) {\n    strcpy(pausedtext, \"paused\");\n    drawString(pausedtext, w / 2 - strlen(pausedtext) / 2, h / 2);\n  }\n\n#if DEBUG_TEXT_BASIC\n  char debugtext[80];\n  Vec3d_toString(&game->player.goose->position, debugtext);\n  drawString(debugtext, 20, 20);\n\n  char characterString[120];\n  Character* character;\n  for (i = 0, character = game->characters; i < game->charactersCount;\n       i++, character++) {\n    Character_toString(character, characterString);\n    drawString(characterString, 20, glutGet(GLUT_WINDOW_HEIGHT) - 40 * (i + 1));\n  }\n  i++;\n  Player_toString(&game->player, characterString);\n  drawString(characterString, 20, glutGet(GLUT_WINDOW_HEIGHT) - 40 * (i + 1));\n#endif\n\n#if ENABLE_NODEGRAPH_EDITOR\n  drawString(\"NodeGraph Editor Mode\", 20, glutGet(GLUT_WINDOW_HEIGHT) - 20);\n#endif\n\n  // Imgui Rendering\n  drawGUI();\n  ImGui::Render();\n  ImGuiIO& io = ImGui::GetIO();\n  ImGui_ImplOpenGL2_RenderDrawData(ImGui::GetDrawData());\n\n  free(intersectingObjects);\n  free(visibleObjDist);\n  free(worldObjectsVisibility);\n\n  game->profTimeDraw += (CUR_TIME_MS() - profStartDraw);\n  glutSwapBuffers();\n}\n\nvoid updateCameraAngle(float newAngle) {\n  cameraAngle = newAngle;\n  cameraLX = sin(cameraAngle);\n  cameraLZ = -cos(cameraAngle);\n}\n\nvoid turnLeft() {\n  updateCameraAngle(cameraAngle - 0.01f);\n}\n\nvoid turnRight() {\n  updateCameraAngle(cameraAngle + 0.01f);\n}\n\nvoid moveForward() {\n  freeViewPos.x += cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z += cameraLZ * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveBack() {\n  freeViewPos.x -= cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z -= cameraLZ * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveLeft() {\n  freeViewPos.x -= cameraLZ * -FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z -= cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveRight() {\n  freeViewPos.x += cameraLZ * -FREEVIEW_SPEED * N64_SCALE_FACTOR;\n  freeViewPos.z += cameraLX * FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveUp() {\n  freeViewPos.y += FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid moveDown() {\n  freeViewPos.y -= FREEVIEW_SPEED * N64_SCALE_FACTOR;\n}\n\nvoid updateFreeView() {\n  Game* game;\n  game = Game_get();\n\n  for (int key = 0; key < 127; ++key) {\n    if (keysDown[key]) {\n      if (game->freeView && !enableControlsInFreeView) {\n        switch (key) {\n          case 97:  // a\n            moveLeft();\n            break;\n          case 100:  // d\n            moveRight();\n            break;\n          case 119:  // w\n            moveForward();\n            break;\n          case 115:  // s\n            moveBack();\n            break;\n          case 113:  // q\n            turnLeft();\n            break;\n          case 101:  // e\n            turnRight();\n            break;\n          case 114:  // r\n            moveUp();\n            break;\n          case 102:  // f\n            moveDown();\n            break;\n        }\n      }\n\n      if (key == 99 && glgooseFrame % 10 == 0) {  // c\n        game->freeView = !game->freeView;\n        if (game->freeView) {\n          printf(\"changing to freeview\\n\");\n        } else {\n          printf(\"changing from freeview\\n\");\n        }\n      }\n    }\n  }\n}\n\nvoid updateInputs() {\n  Game* game;\n  game = Game_get();\n\n  for (int key = 0; key < 127; ++key) {\n    if (keysDown[key]) {\n      if (!game->freeView || enableControlsInFreeView) {\n        switch (key) {\n          case 113:  // q\n            input.zoomIn = TRUE;\n            break;\n          case 101:  // e\n            input.zoomOut = TRUE;\n            break;\n          case 97:  // a\n            input.direction.x += 1.0;\n            break;\n          case 100:  // d\n            input.direction.x -= 1.0;\n            break;\n          case 119:  // w\n            input.direction.y += 1.0;\n            break;\n          case 115:  // s\n            input.direction.y -= 1.0;\n            break;\n          case 32:  // space\n            input.pickup = true;\n            break;\n          case 118:  // v\n            input.run = true;\n            break;\n        }\n      }\n\n      if (key == 112 && glgooseFrame % 10 == 0) {  // p\n        game->paused = !game->paused;\n      }\n    }\n  }\n}\n\nvoid quit(int exitCode) {\n  ImGui_ImplOpenGL2_Shutdown();\n  ImGui_ImplGLUT_Shutdown();\n  ImGui::DestroyContext();\n  exit(exitCode);\n}\n\nvoid processNormalKeysUp(unsigned char key, int _x, int _y) {\n  ImGui_ImplGLUT_KeyboardUpFunc(key, _x, _y);\n  if (ImGui::GetIO().WantCaptureKeyboard) {\n    return;\n  }\n\n  keysDown[key] = false;\n}\n\nvoid processNormalKeysDown(unsigned char key, int _x, int _y) {\n  ImGui_ImplGLUT_KeyboardFunc(key, _x, _y);\n  if (ImGui::GetIO().WantCaptureKeyboard) {\n    return;\n  }\n\n  keysDown[key] = true;\n\n  if (key == 27) {  // esc\n    quit(0);\n  }\n}\n\nvoid selectObjectAtScreenPos(int x, int y) {\n  Vec3d mouseScreenPos0, mouseScreenPos1;\n  Vec3d raySource, rayTarget, rayDirection;\n  int invY = lastViewport[3] - y;\n\n  // near end, ray origin\n  Vec3d_init(&mouseScreenPos0, x, invY, 0.0f);\n  screenCoordsToWorld(&mouseScreenPos0, &raySource);\n\n  // far end\n  GLfloat depth;\n  glReadPixels(x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &depth);\n  Vec3d_init(&mouseScreenPos1, x, invY, depth);\n  screenCoordsToWorld(&mouseScreenPos1, &rayTarget);\n\n  // ray direction\n  Vec3d_directionTo(&raySource, &rayTarget, &rayDirection);\n\n#if ENABLE_NODEGRAPH_EDITOR\n  selectedNode = -1;\n  for (auto node = nodeGraph.nodes.begin(); node != nodeGraph.nodes.end();\n       ++node) {\n    if (Game_rayIntersectsSphere(&raySource, &rayDirection, &node->position,\n                                 10)) {\n      selectedNode = node->id;\n      break;\n    }\n  }\n#else\n  selectedObject = Game_getIntersectingObject(&raySource, &rayDirection);\n#endif\n}\n\nvoid processMouse(int button, int state, int x, int y) {\n  ImGui_ImplGLUT_MouseFunc(button, state, x, y);\n  if (ImGui::GetIO().WantCaptureMouse) {\n    return;\n  }\n\n  if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {\n    selectObjectAtScreenPos(x, y);\n  }\n}\n\nvoid testCollision() {\n  if (selectedObject) {\n    Vec3d objCenter;\n    Game_getObjCenter(selectedObject, &objCenter);\n    float objRadius = Game_getObjRadius(selectedObject);\n    SphereTriangleCollision result;\n    testCollisionTrace = TRUE;\n    Collision_testMeshSphereCollision(\n        garden_map_collision_collision_mesh, GARDEN_MAP_COLLISION_LENGTH,\n        &objCenter, objRadius, physWorldData.worldMeshSpatialHash, &result);\n    testCollisionTrace = FALSE;\n  } else {\n    testCollisionResult = -1;\n    testCollisionResults.clear();\n  }\n}\n\nvoid updateAndRender() {\n  Game* game;\n  game = Game_get();\n\n  glgooseFrame++;\n  updateFreeView();\n  if (glgooseFrame % updateSkipRate == 0) {\n    updateInputs();\n\n    if (game->tick % 60 == 0) {\n      profAvgCharacters = game->profTimeCharacters / 60.0f;\n      game->profTimeCharacters = 0.0f;\n      profAvgPhysics = game->profTimePhysics / 60.0f;\n      game->profTimePhysics = 0.0f;\n      profAvgDraw = game->profTimeDraw / 60.0f;\n      game->profTimeDraw = 0.0f;\n      profAvgPath = game->profTimePath / 60.0f;\n      game->profTimePath = 0.0f;\n    }\n\n#if DEBUG_COLLISION_MESH\n    testCollision();\n#endif\n#if DEBUG_PATHFINDING\n    // doTestPathfinding(FALSE);\n#endif\n\n    Game_update(&input);\n  }\n\n  renderScene();\n}\n\nint main(int argc, char** argv) {\n  int i;\n\n  Game* game;\n  GameObject* obj;\n\n  Game_init(garden_map_data, GARDEN_MAP_COUNT, &physWorldData);\n\n  game = Game_get();\n  game->pathfindingGraph = pathfindingGraph;\n  game->pathfindingState = pathfindingState;\n\n  freeViewPos = game->player.goose->position;\n  freeViewPos.x += 10;\n  freeViewPos.z += 10;\n\n  Input_init(&input);\n\n  updateCameraAngle(180);\n\n  for (i = 0, obj = game->worldObjects; i < game->worldObjectsCount;\n       i++, obj++) {\n    printf(\"loaded obj %d %s  {x:%.3f, y:%.3f, z:%.3f}\\n\", obj->id,\n           ModelTypeStrings[obj->modelType], obj->position.x, obj->position.y,\n           obj->position.z);\n  }\n\n  invariant(GARDEN_MAP_COUNT <= MAX_WORLD_OBJECTS);\n\n  // init GLUT and create window\n  glutInit(&argc, argv);\n  glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA | GLUT_MULTISAMPLE);\n  glutInitWindowPosition(300, 100);\n  glutInitWindowSize(1920, 1200);\n  glutCreateWindow(\"Goose\");\n\n  // register callbacks\n  glutDisplayFunc(renderScene);\n  glutIdleFunc(updateAndRender);\n\n  // Setup Dear ImGui context\n  IMGUI_CHECKVERSION();\n  ImGui::CreateContext();\n  ImGuiIO& io = ImGui::GetIO();\n  (void)io;\n  // io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable\n  // Keyboard Controls\n\n  // Setup Dear ImGui style\n  ImGui::StyleColorsDark();\n  // ImGui::StyleColorsClassic();\n\n  // Setup Platform/Renderer bindings\n  ImGui_ImplGLUT_Init();\n  ImGui_ImplGLUT_InstallFuncs();\n  ImGui_ImplOpenGL2_Init();\n\n  // replace some handlers after ImGui_ImplGLUT_InstallFuncs() sets its own\n  // our impls will call the Imgui impls internally\n  glutReshapeFunc(resizeWindow);\n  glutKeyboardFunc(processNormalKeysDown);\n  glutKeyboardUpFunc(processNormalKeysUp);\n  glutMouseFunc(processMouse);\n\n  // OpenGL init\n  glEnable(GL_DEPTH_TEST);\n  glEnable(GL_CULL_FACE);\n\n  // Load models. This has to be after OpenGL init because it creates textures\n  loadModel(GooseModel, \"gooserig.obj\", \"goosetex.bmp\");\n  loadModel(UniFloorModel, \"garden_floor.obj\", \"green.bmp\");\n  loadModel(UniBldgModel, \"garden_bldg.obj\", \"redbldg.bmp\");\n  loadModel(BushModel, \"bush.obj\", \"bush.bmp\");\n  loadModel(FlagpoleModel, \"flagpole.obj\", \"flagpole.bmp\");\n  loadModel(GardenerCharacterModel, \"characterrig.obj\", \"person.bmp\");\n  loadModel(BookItemModel, \"book.obj\", \"book.bmp\");\n  loadModel(HomeworkItemModel, \"testingCube.obj\", \"testCubeTex.bmp\");\n  loadModel(WallModel, \"wall.obj\", \"wall.bmp\");\n  loadModel(PlanterModel, \"planter.obj\", \"planter.bmp\");\n  loadModel(GroundModel, \"ground.obj\", \"gardengrass.bmp\");\n  loadModel(WaterModel, \"water.obj\", \"water.bmp\");\n  loadModel(RockModel, \"rocks.obj\", \"rock.bmp\");\n  loadModel(WatergrassModel, \"watergrass.obj\", \"watergrass.bmp\");\n  loadModel(ReedModel, \"reed.obj\", \"reed.bmp\");\n  loadModel(LilypadModel, \"lilypad.obj\", \"lilypad.bmp\");\n\n  loadSprite(NoneSprite, {\"testspr.bmp\"});\n  // loadSprite(HonkSprite, {\"honk1spr.bmp\", \"honk2spr.bmp\", \"honk3spr.bmp\"});\n\n#if ENABLE_NODEGRAPH_EDITOR\n  nodeGraph.load(pathfindingGraph);\n#endif\n\n  // enter GLUT event processing cycle\n  glutMainLoop();\n\n  quit(1);\n}\n",
							"origin_encoding": "GBK",
							"revert_to_scratch": true,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "graphic.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9094,
						"regions":
						{
						},
						"selection":
						[
							[
								166,
								166
							]
						],
						"settings":
						{
							"SL.1396.region_keys":
							[
								"sublime_linter.protected_regions"
							],
							"SL.14.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "renderer.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11937,
						"regions":
						{
						},
						"selection":
						[
							[
								5174,
								5174
							]
						],
						"settings":
						{
							"SL.1274.region_keys":
							[
								"SL.clang.Highlights.|cdc1dcafa6faae1144e1229b32ab2f7d86232f281cfda199499d2f3da28d02c6|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Highlights.|98a12ab226c0416794f6624422a8fdbc8e1294c223c92bb307d20e277f8916b4|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.clang.Highlights.|f264e8354d9a918786052fa91c8c8fd0025259a89ae8b8d9a7258b4cbccba481|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Highlights.|05ce9d4053d54e2a2bc5dd000c89d55f048e314104ad4c1c4bda56fc9004a86c|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Gutter.|region.yellowish markup.warning.sublime_linter|dot"
							],
							"SL.15.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "renderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2143,
						"regions":
						{
						},
						"selection":
						[
							[
								236,
								236
							]
						],
						"settings":
						{
							"SL.1276.region_keys":
							[
								"sublime_linter.protected_regions"
							],
							"SL.16.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "frustum.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2119,
						"regions":
						{
						},
						"selection":
						[
							[
								1028,
								1050
							]
						],
						"settings":
						{
							"SL.1281.region_keys":
							[
								"sublime_linter.protected_regions"
							],
							"SL.17.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "spec",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2630,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"SL.18.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content"
							],
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "Makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1068,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"SL.19.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/Makefile/Makefile.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "build_cached.sh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 297,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"SL.1934.region_keys":
							[
								"SL.shellcheck.Highlights.|3767870e7ba1eb97933c518f2882c882e98fcd3d215c46cc90cc1bb7b276a95b|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.shellcheck.Gutter.|region.yellowish markup.warning.sublime_linter|dot"
							],
							"SL.20.region_keys":
							[
								"SL.shellcheck.Gutter.|region.yellowish markup.warning.sublime_linter|dot",
								"sublime_linter.protected_regions",
								"SL.shellcheck.Highlights.|3767870e7ba1eb97933c518f2882c882e98fcd3d215c46cc90cc1bb7b276a95b|region.yellowish markup.warning.sublime_linter|32"
							],
							"SL.21.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/ShellScript/Bash.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "build.sh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 77,
						"regions":
						{
						},
						"selection":
						[
							[
								32,
								32
							]
						],
						"settings":
						{
							"SL.1935.region_keys":
							[
								"SL.shellcheck.Highlights.|fb3daeb8594a0b6fc2109a6ba6cd60526cd0c85e442846d47535c8840277815b|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.shellcheck.Gutter.|region.yellowish markup.warning.sublime_linter|dot"
							],
							"SL.21.region_keys":
							[
								"SL.shellcheck.Gutter.|region.yellowish markup.warning.sublime_linter|dot",
								"sublime_linter.protected_regions",
								"SL.shellcheck.Highlights.|fb3daeb8594a0b6fc2109a6ba6cd60526cd0c85e442846d47535c8840277815b|region.yellowish markup.warning.sublime_linter|32"
							],
							"SL.22.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/ShellScript/Bash.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "frustum.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14164,
						"regions":
						{
						},
						"selection":
						[
							[
								644,
								644
							]
						],
						"settings":
						{
							"SL.1284.region_keys":
							[
								"SL.clang.Highlights.|620b3f6a87cd81dce38c99e916b1f4209c070cf11c875ba93d6072a2fb489774|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Highlights.|dd173837e0c9b848d5a4b1db897a67867363f329895a93cbca4ca4894cc8755c|region.yellowish markup.warning.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.clang.Highlights.|361d2d54836ed02435338c815e43a3a4b379903e49cbd38cead54bf57f096909|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Highlights.|c3502ae5ff58e39730e9b8c216e56b279d9726cf634e3d9a00e6d68e1dbc8330|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Highlights.|244b410bfe7f31ce0cc01cf020742c94fbd3d390a7ef51c146c9cc88286c7c58|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Highlights.|188c88da1397a993e224860fa8fe8568c550a5810b9c92c206948be6a8ea7afe|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Highlights.|8c975dd55a88e2d317037e26ce46e7d78cc3a5e950cfce4e97d1351cb1801e30|region.yellowish markup.warning.sublime_linter|32",
								"SL.clang.Gutter.|region.yellowish markup.warning.sublime_linter|dot",
								"SL.clang.Highlights.|cb4bc07bd03dc779b80dfdc2f67c99d36b4336fad56227ed4cf76d4bc411328a|region.yellowish markup.warning.sublime_linter|32"
							],
							"SL.23.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "vec3d.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3464,
						"regions":
						{
						},
						"selection":
						[
							[
								2439,
								2439
							]
						],
						"settings":
						{
							"SL.1279.region_keys":
							[
								"SL.clang.Highlights.|661da3dadd80e6135f236b625fa15f111f1af61a16903d4594b6cc63deb240b3|region.redish markup.error.sublime_linter|32",
								"sublime_linter.protected_regions",
								"SL.clang.Gutter.|region.redish markup.error.sublime_linter|dot"
							],
							"SL.24.region_keys":
							[
							],
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 31.0
	},
	"input":
	{
		"height": 44.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.SublimeLinter Messages":
	{
		"height": 407.0
	},
	"output.aaa_package_dev":
	{
		"height": 116.0
	},
	"output.exec":
	{
		"height": 382.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"output.package_dev":
	{
		"height": 116.0
	},
	"output.unsaved_changes":
	{
		"height": 138.0
	},
	"pinned_build_system": "",
	"project": "goose64glut.sublime-project",
	"replace":
	{
		"height": 58.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"sepc",
				"spec"
			],
			[
				"buidc",
				"build_cached.sh"
			],
			[
				"bui",
				"build.sh"
			],
			[
				"buid",
				"build.sh"
			],
			[
				"buildcac",
				"build_cached.sh"
			],
			[
				"buil",
				"build.sh"
			],
			[
				"make",
				"Makefile"
			],
			[
				"buildmode",
				"build_modern.sh"
			],
			[
				"graph",
				"graphic.c"
			],
			[
				"stage",
				"stage00.c"
			],
			[
				"renh",
				"renderer.h"
			],
			[
				"ed",
				"ed64io_usb.c"
			],
			[
				"gl",
				"glgoose.cpp"
			],
			[
				"glgoo",
				"glgoose.cpp"
			],
			[
				"proj",
				"goose64.sublime-project"
			],
			[
				"path",
				"pathfinding.h"
			],
			[
				"no",
				"nodegraph/nodegraph.hpp"
			],
			[
				"unimepcol",
				"university_map_collision.h"
			],
			[
				"unimaco",
				"university_map_collision.c"
			],
			[
				"sta",
				"stage00.c"
			],
			[
				"glg",
				"glgoose.cpp"
			],
			[
				".h",
				"game.h"
			],
			[
				"state",
				"characterstate.h"
			],
			[
				"charah",
				"character.h"
			],
			[
				"chara",
				"character.c"
			],
			[
				"charasta",
				"characterstate.c"
			],
			[
				"characsta",
				"characterstate.h"
			],
			[
				"note",
				"NOTES.md"
			],
			[
				"rea",
				"README.md"
			],
			[
				"giti",
				".gitignore"
			],
			[
				"com",
				"compile.bat"
			],
			[
				"deply",
				"deploy.sh"
			],
			[
				".bat",
				"compile.bat"
			],
			[
				"glgo",
				"glgoose.cpp"
			],
			[
				"vec2d",
				"vec2d.c"
			],
			[
				"tria",
				"triangleraster.js"
			],
			[
				"ed64io_everdrive.h",
				"ed64io_everdrive.h"
			],
			[
				"read",
				"README.md"
			],
			[
				"depl",
				"deploy.sh"
			],
			[
				"mak",
				"Makefile"
			],
			[
				"mode",
				"modeltype.h"
			],
			[
				"model",
				"modeltype.c"
			],
			[
				"charcpp",
				"characterstate.cpp"
			],
			[
				"consta",
				"constants.h"
			],
			[
				"ediou",
				"ed64io_usb.h"
			],
			[
				"usbh",
				"ed64io_usb.h"
			],
			[
				"makef",
				"Makefile"
			],
			[
				"ed64io/usb.h",
				"ed64io/usb.h"
			],
			[
				"bush.",
				"bush.h"
			],
			[
				"wall",
				"wall.h"
			],
			[
				"stag",
				"stage00.c"
			],
			[
				"univemap",
				"university_map.h"
			],
			[
				"conta",
				"constants.h"
			],
			[
				"phy",
				"physics.c"
			],
			[
				"expoer",
				"export_character_model.py"
			],
			[
				"collh",
				"collision.h"
			],
			[
				"phys",
				"physics.h"
			],
			[
				"json",
				"university_map_collision.json"
			],
			[
				"univermapco",
				"university_map_collision.h"
			],
			[
				"const",
				"constants.h"
			],
			[
				"constan",
				"constants.h"
			],
			[
				"",
				"glgoose.cpp"
			],
			[
				"modetp",
				"modeltype.c"
			],
			[
				"univmap",
				"university_map.h"
			],
			[
				"vec",
				"vec3d.h"
			],
			[
				"v3",
				"vec3d.c"
			],
			[
				"unimap",
				"university_map.h"
			],
			[
				"glo",
				"glgoose.cpp"
			],
			[
				"ph",
				"physics.c"
			],
			[
				"constants",
				"constants.h"
			],
			[
				"collc",
				"collision.c"
			],
			[
				"cons",
				"constants.h"
			],
			[
				"objloader.hpp",
				"gl/objloader.hpp"
			],
			[
				"game",
				"game.c"
			],
			[
				"v3d",
				"vec3d.c"
			],
			[
				"ve",
				"vec3d.h"
			],
			[
				"vec3d",
				"vec3d.h"
			],
			[
				"exporpo",
				"export_positions.py"
			],
			[
				"modeltyp",
				"modeltype.c"
			],
			[
				"exampleglcpp",
				"imgui/examples/example_glut_opengl2/main.cpp"
			],
			[
				"demo",
				"imgui/imgui_demo.cpp"
			],
			[
				"g",
				"glgoose.cpp"
			],
			[
				"Game.h",
				"game.h"
			],
			[
				"GameObj",
				"gameobject.c"
			],
			[
				"Vec",
				"vec3d.c"
			],
			[
				"gameh",
				"game.h"
			],
			[
				"glut2mak",
				"imgui/examples/example_glut_opengl2/Makefile"
			],
			[
				"exaglut",
				"imgui/examples/example_glut_opengl2/main.cpp"
			],
			[
				"expora",
				"export_animation.py"
			],
			[
				"charach",
				"character.h"
			],
			[
				"char",
				"character.c"
			],
			[
				"expor",
				"export_character_model.py"
			],
			[
				"expoch",
				"export_character_model.py"
			],
			[
				"physi",
				"physics.c"
			],
			[
				"characc",
				"character.c"
			],
			[
				"expo",
				"export_character_model.py"
			],
			[
				"pla",
				"player.c"
			],
			[
				"chrac",
				"character.c"
			],
			[
				"pl",
				"player.c"
			],
			[
				"chrarig",
				"characterrig.h"
			],
			[
				"charaob",
				"characterrig.obj"
			],
			[
				"chracrigob",
				"characterrig.obj"
			],
			[
				"art",
				"ART.md"
			],
			[
				"animtype",
				"gooseanimtypes.h"
			],
			[
				"wave",
				"wavefront64/wavefront64.lua"
			],
			[
				"rebui",
				"rebuild_models.sh"
			],
			[
				"chararig",
				"characterrig.obj"
			],
			[
				"charaanim",
				"character_anim.h"
			],
			[
				"exporan",
				"export_animation.py"
			],
			[
				"chaa",
				"character.h"
			],
			[
				"Model",
				"modeltype.c"
			],
			[
				"vec3",
				"vec3d.c"
			],
			[
				"exporpos",
				"export_positions.py"
			],
			[
				"de",
				"deploy.sh"
			],
			[
				"glsh",
				"glbuild.sh"
			],
			[
				"mae",
				"Makefile"
			],
			[
				"item",
				"item.c"
			],
			[
				"hyh",
				"physics.h"
			],
			[
				"plah",
				"player.h"
			],
			[
				"play",
				"player.c"
			],
			[
				"gameobj",
				"gameobject.h"
			],
			[
				"gametyp",
				"gametypes.h"
			],
			[
				"ani",
				"animation.h"
			],
			[
				"intp",
				"input.c"
			],
			[
				"in",
				"input.h"
			],
			[
				"plaer",
				"player.c"
			],
			[
				"gametypes",
				"gametypes.h"
			],
			[
				"itemh",
				"item.h"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/code/posts/posts.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 53.0,
		"last_filter": "worldCoordsToScreen",
		"selected_items":
		[
			[
				"worldCoordsToScreen",
				"worldCoordsToScreen"
			],
			[
				"drawStringAtPoint",
				"drawStringAtPoint"
			],
			[
				"Renderer_calcIntersecting",
				"Renderer_calcIntersecting"
			],
			[
				"Vec3d_dot",
				"Vec3d_dot"
			],
			[
				"drawTriNormal",
				"drawTriNormal"
			],
			[
				"drawMotionVectorLine",
				"drawMotionVectorLine"
			],
			[
				"Plane_distance",
				"Plane_distance"
			],
			[
				"drawPl",
				"drawPlane"
			],
			[
				"draw",
				"drawPhysBall"
			],
			[
				"plane",
				"Plane"
			],
			[
				"Vec3d_cross",
				"Vec3d_cross"
			],
			[
				"euler",
				"EulerDegrees_fromEuler"
			],
			[
				"Renderer_closestPointOnAABB",
				"Renderer_closestPointOnAABB"
			],
			[
				"RendererSortDistance",
				"RendererSortDistance"
			],
			[
				"direc",
				"Vec3d_directionTo"
			],
			[
				"direction",
				"Vec3d_directionTo"
			],
			[
				"Plane_setNormalAndPoint",
				"Plane_setNormalAndPoint"
			],
			[
				"drawMarker",
				"drawMarker"
			],
			[
				"distance",
				"Vec3d_distanceTo"
			],
			[
				"Game_getObjCenter",
				"Game_getObjCenter"
			],
			[
				"drawG",
				"drawGUI"
			],
			[
				"plan",
				"Plane"
			],
			[
				"Vec3d_distanceTo",
				"Vec3d_distanceTo"
			],
			[
				"Renderer_sortVisibleObjects",
				"Renderer_sortVisibleObjects"
			],
			[
				"CLAMP",
				"CLAMP"
			],
			[
				"bmp",
				"loadBMP_custom"
			],
			[
				"loadBMP_custom",
				"loadBMP_custom"
			],
			[
				"Vec3d_directionTo",
				"Vec3d_directionTo"
			],
			[
				"deg",
				"degToRad"
			],
			[
				"objmode",
				"ObjModel"
			],
			[
				"stage",
				"stage00"
			],
			[
				"timeInMilliseconds",
				"timeInMilliseconds"
			],
			[
				"CUR_TIME_MS",
				"CUR_TIME_MS"
			],
			[
				"game",
				"Game"
			],
			[
				"debugPrintf",
				"debugPrintf"
			],
			[
				"drawPath",
				"drawPathfindingGraph"
			],
			[
				"Vec3d_toString",
				"Vec3d_toString"
			],
			[
				"Vec3d",
				"Vec3d"
			],
			[
				"clam",
				"CLAMP"
			],
			[
				"PathfindingState",
				"PathfindingState"
			],
			[
				"NodeState",
				"NodeState"
			],
			[
				"Path_initState",
				"Path_initState"
			],
			[
				"game_in",
				"Game_init"
			],
			[
				"Character_canSee",
				"Character_canSeePlayer"
			],
			[
				"characterini",
				"Character_init"
			],
			[
				"chracter",
				"Character"
			],
			[
				"semimple",
				"PhysBody_integrateMotionSemiImplicitEuler"
			],
			[
				"sleep",
				"sleep"
			],
			[
				"SP_regs_s",
				"_SP_regs_s"
			],
			[
				"dma_read_s",
				"dma_read_s"
			],
			[
				"IO_WRITE",
				"IO_WRITE"
			],
			[
				"constants",
				"CONSTANTS_H"
			],
			[
				"print",
				"printf"
			],
			[
				"usbLoggerLog",
				"usbLoggerLog"
			],
			[
				"evd_fifoWr",
				"evd_fifoWr"
			],
			[
				"evd_isDmaBusy",
				"evd_isDmaBusy"
			],
			[
				"EVD_ERROR_FIFO_TIMEOUT",
				"EVD_ERROR_FIFO_TIMEOUT"
			],
			[
				"evd_fifoTxe",
				"evd_fifoTxe"
			],
			[
				"evdPiWriteRom",
				"evdPiWriteRom"
			],
			[
				"evd_isDmaTimeout",
				"evd_isDmaTimeout"
			],
			[
				"NU_PI_CART_BLOCK_READ_SIZE",
				"NU_PI_CART_BLOCK_READ_SIZE"
			],
			[
				"dma_write_s",
				"dma_write_s"
			],
			[
				"evd_fifoWrNonblock",
				"evd_fifoWrNonblock"
			],
			[
				"usbListener",
				"usbListener"
			],
			[
				"evd_fifoWrFromCart",
				"evd_fifoWrFromCart"
			],
			[
				"evd_fifoRxf",
				"evd_fifoRxf"
			],
			[
				"evd_init",
				"evd_init"
			],
			[
				"io_wr",
				"IO_WRITE"
			],
			[
				"io_",
				"IO_READ"
			],
			[
				"evd_fifoRd",
				"evd_fifoRd"
			],
			[
				"rendersce",
				"renderScene"
			],
			[
				"gameup",
				"Game_update"
			],
			[
				"Game_findObjectByType",
				"Game_findObjectByType"
			],
			[
				"chara",
				"Character_update"
			],
			[
				"drawgu",
				"drawGUI"
			],
			[
				"e",
				"Euler"
			],
			[
				"phy",
				"PhysBody"
			],
			[
				"translatewi",
				"PhysBody_translateWithoutForce"
			],
			[
				"Collision_distancePointTriangleExact",
				"Collision_distancePointTriangleExact"
			],
			[
				"SphereTriangleCollision",
				"SphereTriangleCollision"
			],
			[
				"centroid",
				"Triangle_getCentroid"
			],
			[
				"PhysWorldData",
				"PhysWorldData"
			],
			[
				"UNIVERSITY_MAP_COLLISION_LENGTH",
				"UNIVERSITY_MAP_COLLISION_LENGTH"
			],
			[
				"testC",
				"testCollision"
			],
			[
				"Collision_testMeshSphereCollision",
				"Collision_testMeshSphereCollision"
			],
			[
				"drawcol",
				"drawCollisionMesh"
			],
			[
				"SpatialHash_getBucket",
				"SpatialHash_getBucket"
			],
			[
				"drawCo",
				"drawCollisionMesh"
			],
			[
				"create_spatial_hash",
				"create_spatial_hash"
			],
			[
				"drawg",
				"drawGUI"
			],
			[
				"Spat",
				"SpatialHashBucket"
			],
			[
				"physW",
				"PhysWorldData"
			],
			[
				"physinte",
				"PhysBody_integrateBodies"
			],
			[
				"PhysState_step",
				"PhysState_step"
			],
			[
				"gameupda",
				"Game_updatePhysics"
			],
			[
				"gameini",
				"Game_init"
			],
			[
				"characupda",
				"Character_update"
			],
			[
				"game_upda",
				"Game_update"
			],
			[
				"phyup",
				"PhysBody_update"
			],
			[
				"integra",
				"PhysBody_integrateMotion"
			],
			[
				"worldData",
				"PhysWorldData"
			],
			[
				"PhysState_init",
				"PhysState_init"
			],
			[
				"Game_init",
				"Game_init"
			],
			[
				"drawgui",
				"drawGUI"
			],
			[
				"Vec3d_normalise",
				"Vec3d_normalise"
			],
			[
				"getNorm",
				"Triangle_getNormal"
			],
			[
				"charac",
				"Character"
			],
			[
				"Collision_sphereTriangleIsSeparated",
				"Collision_sphereTriangleIsSeparated"
			],
			[
				"Triangle_getNormal",
				"Triangle_getNormal"
			],
			[
				"PhysState",
				"PhysState"
			],
			[
				"loado",
				"loadOBJ"
			],
			[
				"min",
				"MIN"
			],
			[
				"ve2d",
				"VEC2D_H"
			],
			[
				"Vec3d_print",
				"Vec3d_print"
			],
			[
				"InputInt",
				"Input_init"
			],
			[
				"updatePh",
				"Game_updatePhysics"
			],
			[
				"updaph",
				"Game_updatePhysics"
			],
			[
				"gameu",
				"Game_update"
			],
			[
				"Game_update",
				"Game_update"
			],
			[
				"objCenter",
				"Game_getObjCenter"
			],
			[
				"getObj",
				"Game_getObjCenter"
			],
			[
				"gameupdaph",
				"Game_updatePhysics"
			],
			[
				"getCen",
				"GetCenter"
			],
			[
				"model",
				"ModelProperties"
			],
			[
				"physb",
				"PhysBody"
			],
			[
				"ImGuiInputTextFlags",
				"ImGuiInputTextFlags_"
			],
			[
				"inputFlo",
				"InputFloat"
			],
			[
				"phys",
				"PhysBody"
			]
		],
		"width": 560.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 355.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
